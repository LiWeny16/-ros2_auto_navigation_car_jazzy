build/auto_control/Testing/20250526-0636/Test.xml: 5 tests, 0 errors, 2 failures, 0 skipped
- test_controller
  <<< failure message
    -- run_test.py: invoking following command in '/home/onion/samples/autonomous_driving_ws/build/auto_control':
     - /home/onion/samples/autonomous_driving_ws/build/auto_control/test_controller --gtest_output=xml:/home/onion/samples/autonomous_driving_ws/build/auto_control/test_results/auto_control/test_controller.gtest.xml
    [==========] Running 3 tests from 1 test suite.
    [----------] Global test environment set-up.
    [----------] 3 tests from ControllerTest
    [ RUN      ] ControllerTest.PurePursuitBasicTest
    [       OK ] ControllerTest.PurePursuitBasicTest (0 ms)
    [ RUN      ] ControllerTest.ApproachGoalTest
    /home/onion/samples/autonomous_driving_ws/src/auto_control/test/test_controller.cpp:180: Failure
    Expected: (cmd.brake) > (0.0), actual: 0 vs 0
    [  FAILED  ] ControllerTest.ApproachGoalTest (0 ms)
    [ RUN      ] ControllerTest.CurvedPathTest
    [       OK ] ControllerTest.CurvedPathTest (0 ms)
    [----------] 3 tests from ControllerTest (0 ms total)
    
    [----------] Global test environment tear-down
    [==========] 3 tests from 1 test suite ran. (0 ms total)
    [  PASSED  ] 2 tests.
    [  FAILED  ] 1 test, listed below:
    [  FAILED  ] ControllerTest.ApproachGoalTest
    
     1 FAILED TEST
    -- run_test.py: return code 1
    -- run_test.py: inject classname prefix into gtest result file '/home/onion/samples/autonomous_driving_ws/build/auto_control/test_results/auto_control/test_controller.gtest.xml'
    -- run_test.py: verify result file '/home/onion/samples/autonomous_driving_ws/build/auto_control/test_results/auto_control/test_controller.gtest.xml'
  >>>
- uncrustify
  <<< failure message
    -- run_test.py: invoking following command in '/home/onion/samples/autonomous_driving_ws/src/auto_control':
     - /opt/ros/humble/bin/ament_uncrustify --xunit-file /home/onion/samples/autonomous_driving_ws/build/auto_control/test_results/auto_control/uncrustify.xunit.xml
    Code style divergence in file 'include/auto_control/pure_pursuit_controller.hpp':
    
    --- include/auto_control/pure_pursuit_controller.hpp
    +++ include/auto_control/pure_pursuit_controller.hpp.uncrustify
    @@ -11 +11,2 @@
    -namespace auto_control {
    +namespace auto_control
    +{
    @@ -13,7 +14,8 @@
    -struct ControlCommand {
    -    double steering_angle;  // 转向角度（弧度）
    -    double throttle;        // 油门（范围：0-1）
    -    double brake;           // 制动（范围：0-1）
    -    
    -    ControlCommand(double steering = 0.0, double throttle = 0.0, double brake = 0.0)
    -        : steering_angle(steering), throttle(throttle), brake(brake) {}
    +struct ControlCommand
    +{
    +  double steering_angle;    // 转向角度（弧度）
    +  double throttle;          // 油门（范围：0-1）
    +  double brake;             // 制动（范围：0-1）
    +
    +  ControlCommand(double steering = 0.0, double throttle = 0.0, double brake = 0.0)
    +  : steering_angle(steering), throttle(throttle), brake(brake) {}
    @@ -22 +24,2 @@
    -class PurePursuitController {
    +class PurePursuitController
    +{
    @@ -24,2 +27,2 @@
    -    PurePursuitController();
    -    virtual ~PurePursuitController() = default;
    +  PurePursuitController();
    +  virtual ~PurePursuitController() = default;
    @@ -27,19 +30,19 @@
    -    // 设置路径
    -    void setPath(const auto_msgs::msg::PlanningPath& path);
    -    
    -    // 计算控制命令
    -    ControlCommand calculateControl(
    -        const geometry_msgs::msg::Pose& current_pose,
    -        const geometry_msgs::msg::Twist& current_velocity);
    -    
    -    // 设置预瞄距离（米）
    -    void setLookaheadDistance(double distance);
    -    
    -    // 设置最大速度（米/秒）
    -    void setMaxVelocity(double velocity);
    -    
    -    // 检查是否有路径
    -    bool hasPath() const;
    -    
    -    // 检查是否到达目标
    -    bool reachedGoal() const;
    +  // 设置路径
    +  void setPath(const auto_msgs::msg::PlanningPath & path);
    +
    +  // 计算控制命令
    +  ControlCommand calculateControl(
    +    const geometry_msgs::msg::Pose & current_pose,
    +    const geometry_msgs::msg::Twist & current_velocity);
    +
    +  // 设置预瞄距离（米）
    +  void setLookaheadDistance(double distance);
    +
    +  // 设置最大速度（米/秒）
    +  void setMaxVelocity(double velocity);
    +
    +  // 检查是否有路径
    +  bool hasPath() const;
    +
    +  // 检查是否到达目标
    +  bool reachedGoal() const;
    @@ -48,35 +51,35 @@
    -    // 查找最近的路径点索引
    -    size_t findClosestPointIndex(const geometry_msgs::msg::Pose& pose);
    -    
    -    // 查找预瞄点
    -    std::pair<bool, geometry_msgs::msg::Pose> findLookaheadPoint(
    -        const geometry_msgs::msg::Pose& pose, size_t start_index);
    -    
    -    // 计算两点之间的欧氏距离
    -    double calculateDistance(
    -        const geometry_msgs::msg::Point& p1, 
    -        const geometry_msgs::msg::Point& p2);
    -    
    -    // 路径点
    -    std::vector<auto_msgs::msg::PathPoint> path_points_;
    -    
    -    // 最后处理的索引
    -    size_t last_closest_index_;
    -    
    -    // 预瞄距离（米）
    -    double lookahead_distance_;
    -    
    -    // 车辆轴距（米）
    -    double wheelbase_;
    -    
    -    // 最大速度（米/秒）
    -    double max_velocity_;
    -    
    -    // 目标速度控制参数
    -    double speed_p_gain_;
    -    
    -    // 是否已经设置路径
    -    bool has_path_;
    -    
    -    // 是否到达目标
    -    bool reached_goal_;
    +  // 查找最近的路径点索引
    +  size_t findClosestPointIndex(const geometry_msgs::msg::Pose & pose);
    +
    +  // 查找预瞄点
    +  std::pair<bool, geometry_msgs::msg::Pose> findLookaheadPoint(
    +    const geometry_msgs::msg::Pose & pose, size_t start_index);
    +
    +  // 计算两点之间的欧氏距离
    +  double calculateDistance(
    +    const geometry_msgs::msg::Point & p1,
    +    const geometry_msgs::msg::Point & p2);
    +
    +  // 路径点
    +  std::vector<auto_msgs::msg::PathPoint> path_points_;
    +
    +  // 最后处理的索引
    +  size_t last_closest_index_;
    +
    +  // 预瞄距离（米）
    +  double lookahead_distance_;
    +
    +  // 车辆轴距（米）
    +  double wheelbase_;
    +
    +  // 最大速度（米/秒）
    +  double max_velocity_;
    +
    +  // 目标速度控制参数
    +  double speed_p_gain_;
    +
    +  // 是否已经设置路径
    +  bool has_path_;
    +
    +  // 是否到达目标
    +  bool reached_goal_;
    
    Code style divergence in file 'src/controller_node.cpp':
    
    --- src/controller_node.cpp
    +++ src/controller_node.cpp.uncrustify
    @@ -19,3 +19,5 @@
    -namespace auto_control {
    -
    -class ControllerNode : public rclcpp::Node {
    +namespace auto_control
    +{
    +
    +class ControllerNode : public rclcpp::Node
    +{
    @@ -23,32 +25,47 @@
    -    ControllerNode() : Node("controller_node") {
    -        // 创建控制器
    -        controller_ = std::make_unique<PurePursuitController>();
    -        controller_->setLookaheadDistance(3.0);
    -        controller_->setMaxVelocity(5.0);
    -        
    -        // 创建订阅者
    -        path_sub_ = this->create_subscription<auto_msgs::msg::PlanningPath>(
    -            "planning_path", 10, std::bind(&ControllerNode::pathCallback, this, _1));
    -        
    -        // 创建发布者
    -        cmd_vis_pub_ = this->create_publisher<visualization_msgs::msg::MarkerArray>(
    -            "control_markers", 10);
    -        
    -        // 初始化模拟的车辆状态
    -        vehicle_pose_.header.frame_id = "map";
    -        vehicle_pose_.pose.position.x = 0.0;
    -        vehicle_pose_.pose.position.y = 0.0;
    -        vehicle_pose_.pose.position.z = 0.0;
    -        tf2::Quaternion q;
    -        q.setRPY(0.0, 0.0, 0.0);
    -        vehicle_pose_.pose.orientation = tf2::toMsg(q);
    -        
    -        vehicle_velocity_.linear.x = 0.0;
    -        vehicle_velocity_.linear.y = 0.0;
    -        vehicle_velocity_.angular.z = 0.0;
    -        
    -        // 创建定时器用于控制循环和车辆状态更新
    -        control_timer_ = this->create_wall_timer(
    -            50ms, std::bind(&ControllerNode::controlLoop, this));
    -        
    -        RCLCPP_INFO(this->get_logger(), "控制节点已启动");
    +  ControllerNode()
    +  : Node("controller_node")
    +  {
    +    // 创建控制器
    +    controller_ = std::make_unique<PurePursuitController>();
    +    controller_->setLookaheadDistance(3.0);
    +    controller_->setMaxVelocity(5.0);
    +
    +    // 创建订阅者
    +    path_sub_ = this->create_subscription<auto_msgs::msg::PlanningPath>(
    +      "planning_path", 10, std::bind(&ControllerNode::pathCallback, this, _1));
    +
    +    // 创建发布者
    +    cmd_vis_pub_ = this->create_publisher<visualization_msgs::msg::MarkerArray>(
    +      "control_markers", 10);
    +
    +    // 初始化模拟的车辆状态
    +    vehicle_pose_.header.frame_id = "map";
    +    vehicle_pose_.pose.position.x = 0.0;
    +    vehicle_pose_.pose.position.y = 0.0;
    +    vehicle_pose_.pose.position.z = 0.0;
    +    tf2::Quaternion q;
    +    q.setRPY(0.0, 0.0, 0.0);
    +    vehicle_pose_.pose.orientation = tf2::toMsg(q);
    +
    +    vehicle_velocity_.linear.x = 0.0;
    +    vehicle_velocity_.linear.y = 0.0;
    +    vehicle_velocity_.angular.z = 0.0;
    +
    +    // 创建定时器用于控制循环和车辆状态更新
    +    control_timer_ = this->create_wall_timer(
    +      50ms, std::bind(&ControllerNode::controlLoop, this));
    +
    +    RCLCPP_INFO(this->get_logger(), "控制节点已启动");
    +  }
    +
    +private:
    +  void pathCallback(const auto_msgs::msg::PlanningPath::SharedPtr msg)
    +  {
    +    RCLCPP_INFO(this->get_logger(), "收到路径，点数: %zu", msg->points.size());
    +    controller_->setPath(*msg);
    +  }
    +
    +  void controlLoop()
    +  {
    +    if (!controller_->hasPath()) {
    +      return;
    @@ -57,4 +74,12 @@
    -private:
    -    void pathCallback(const auto_msgs::msg::PlanningPath::SharedPtr msg) {
    -        RCLCPP_INFO(this->get_logger(), "收到路径，点数: %zu", msg->points.size());
    -        controller_->setPath(*msg);
    +    // 计算控制命令
    +    auto cmd = controller_->calculateControl(vehicle_pose_.pose, vehicle_velocity_);
    +
    +    // 更新车辆状态（简单运动学模型）
    +    updateVehicleState(cmd);
    +
    +    // 可视化控制结果
    +    visualizeControl(cmd);
    +
    +    // 检查是否到达目标
    +    if (controller_->reachedGoal()) {
    +      RCLCPP_INFO(this->get_logger(), "已到达目标位置！");
    @@ -62,191 +87,180 @@
    -    
    -    void controlLoop() {
    -        if (!controller_->hasPath()) {
    -            return;
    -        }
    -        
    -        // 计算控制命令
    -        auto cmd = controller_->calculateControl(vehicle_pose_.pose, vehicle_velocity_);
    -        
    -        // 更新车辆状态（简单运动学模型）
    -        updateVehicleState(cmd);
    -        
    -        // 可视化控制结果
    -        visualizeControl(cmd);
    -        
    -        // 检查是否到达目标
    -        if (controller_->reachedGoal()) {
    -            RCLCPP_INFO(this->get_logger(), "已到达目标位置！");
    -        }
    -    }
    -    
    -    void updateVehicleState(const ControlCommand& cmd) {
    -        // 获取当前状态
    -        double x = vehicle_pose_.pose.position.x;
    -        double y = vehicle_pose_.pose.position.y;
    -        tf2::Quaternion quat;
    -        tf2::fromMsg(vehicle_pose_.pose.orientation, quat);
    -        double yaw = tf2::impl::getYaw(quat);
    -        double v = vehicle_velocity_.linear.x;
    -        
    -        // 时间步长
    -        double dt = 0.05;  // 50ms
    -        
    -        // 计算加速度（简化）
    -        double acceleration = cmd.throttle * 2.0 - cmd.brake * 5.0;  // 简单的加速度模型
    -        
    -        // 更新速度（考虑最大/最小速度限制）
    -        v += acceleration * dt;
    -        v = std::max(0.0, std::min(v, 10.0));  // 速度范围：0-10 m/s
    -        
    -        // 更新位置
    -        double delta = cmd.steering_angle;  // 转向角
    -        double wheelbase = 2.7;  // 车辆轴距
    -        
    -        // 自行车模型
    -        double beta = atan(0.5 * tan(delta));  // 侧偏角
    -        double dx = v * cos(yaw + beta) * dt;
    -        double dy = v * sin(yaw + beta) * dt;
    -        double dyaw = v * tan(delta) * cos(beta) / wheelbase * dt;
    -        
    -        // 更新位置和方向
    -        x += dx;
    -        y += dy;
    -        yaw += dyaw;
    -        
    -        // 规范化角度到[-pi, pi]
    -        while (yaw > M_PI) yaw -= 2.0 * M_PI;
    -        while (yaw < -M_PI) yaw += 2.0 * M_PI;
    -        
    -        // 更新位置
    -        vehicle_pose_.header.stamp = this->now();
    -        vehicle_pose_.pose.position.x = x;
    -        vehicle_pose_.pose.position.y = y;
    -        
    -        // 更新方向
    -        tf2::Quaternion q;
    -        q.setRPY(0.0, 0.0, yaw);
    -        vehicle_pose_.pose.orientation = tf2::toMsg(q);
    -        
    -        // 更新速度
    -        vehicle_velocity_.linear.x = v * cos(yaw);
    -        vehicle_velocity_.linear.y = v * sin(yaw);
    -        vehicle_velocity_.angular.z = v * tan(delta) / wheelbase;
    -    }
    -    
    -    void visualizeControl(const ControlCommand& cmd) {
    -        visualization_msgs::msg::MarkerArray marker_array;
    -        
    -        // 添加车辆标记
    -        visualization_msgs::msg::Marker vehicle_marker;
    -        vehicle_marker.header.frame_id = "map";
    -        vehicle_marker.header.stamp = this->now();
    -        vehicle_marker.ns = "vehicle";
    -        vehicle_marker.id = 0;
    -        vehicle_marker.type = visualization_msgs::msg::Marker::CUBE;
    -        vehicle_marker.action = visualization_msgs::msg::Marker::ADD;
    -        
    -        // 设置位置和方向
    -        vehicle_marker.pose = vehicle_pose_.pose;
    -        
    -        // 设置车辆大小
    -        vehicle_marker.scale.x = 4.5;  // 长度
    -        vehicle_marker.scale.y = 2.0;  // 宽度
    -        vehicle_marker.scale.z = 1.5;  // 高度
    -        
    -        // 设置颜色
    -        vehicle_marker.color.r = 0.2;
    -        vehicle_marker.color.g = 0.2;
    -        vehicle_marker.color.b = 0.8;
    -        vehicle_marker.color.a = 0.8;
    -        
    -        marker_array.markers.push_back(vehicle_marker);
    -        
    -        // 添加轮子标记
    -        double wheelbase = 2.7;
    -        double track_width = 1.6;
    -        
    -        // 前轮（带转向）
    -        double steering_angle = cmd.steering_angle;
    -        
    -        // 左前轮
    -        visualization_msgs::msg::Marker lf_wheel_marker;
    -        lf_wheel_marker.header.frame_id = "map";
    -        lf_wheel_marker.header.stamp = this->now();
    -        lf_wheel_marker.ns = "wheels";
    -        lf_wheel_marker.id = 1;
    -        lf_wheel_marker.type = visualization_msgs::msg::Marker::CUBE;
    -        lf_wheel_marker.action = visualization_msgs::msg::Marker::ADD;
    -        
    -        // 计算轮子位置（车辆坐标系）
    -        double wheel_x_offset = 1.8;  // 前轮到车辆中心的距离
    -        
    -        // 转换到全局坐标系
    -        tf2::Quaternion quat;
    -        tf2::fromMsg(vehicle_pose_.pose.orientation, quat);
    -        double yaw = tf2::impl::getYaw(quat);
    -        
    -        lf_wheel_marker.pose = vehicle_pose_.pose;
    -        lf_wheel_marker.pose.position.x += wheel_x_offset * cos(yaw) - track_width/2 * sin(yaw);
    -        lf_wheel_marker.pose.position.y += wheel_x_offset * sin(yaw) + track_width/2 * cos(yaw);
    -        
    -        // 设置方向（考虑转向）
    -        tf2::Quaternion q_lf;
    -        q_lf.setRPY(0.0, 0.0, yaw + steering_angle);
    -        lf_wheel_marker.pose.orientation = tf2::toMsg(q_lf);
    -        
    -        // 设置轮子大小
    -        lf_wheel_marker.scale.x = 0.7;  // 长度
    -        lf_wheel_marker.scale.y = 0.3;  // 宽度
    -        lf_wheel_marker.scale.z = 0.7;  // 高度
    -        
    -        // 设置颜色
    -        lf_wheel_marker.color.r = 0.1;
    -        lf_wheel_marker.color.g = 0.1;
    -        lf_wheel_marker.color.b = 0.1;
    -        lf_wheel_marker.color.a = 1.0;
    -        
    -        marker_array.markers.push_back(lf_wheel_marker);
    -        
    -        // 右前轮
    -        visualization_msgs::msg::Marker rf_wheel_marker = lf_wheel_marker;
    -        rf_wheel_marker.id = 2;
    -        rf_wheel_marker.pose.position.x = vehicle_pose_.pose.position.x + wheel_x_offset * cos(yaw) + track_width/2 * sin(yaw);
    -        rf_wheel_marker.pose.position.y = vehicle_pose_.pose.position.y + wheel_x_offset * sin(yaw) - track_width/2 * cos(yaw);
    -        rf_wheel_marker.pose.orientation = tf2::toMsg(q_lf);  // 和左前轮一样的转向
    -        
    -        marker_array.markers.push_back(rf_wheel_marker);
    -        
    -        // 左后轮
    -        visualization_msgs::msg::Marker lr_wheel_marker = lf_wheel_marker;
    -        lr_wheel_marker.id = 3;
    -        lr_wheel_marker.pose.position.x = vehicle_pose_.pose.position.x - wheelbase * cos(yaw) - track_width/2 * sin(yaw);
    -        lr_wheel_marker.pose.position.y = vehicle_pose_.pose.position.y - wheelbase * sin(yaw) + track_width/2 * cos(yaw);
    -        
    -        // 后轮没有转向
    -        tf2::Quaternion q_lr;
    -        q_lr.setRPY(0.0, 0.0, yaw);
    -        lr_wheel_marker.pose.orientation = tf2::toMsg(q_lr);
    -        
    -        marker_array.markers.push_back(lr_wheel_marker);
    -        
    -        // 右后轮
    -        visualization_msgs::msg::Marker rr_wheel_marker = lr_wheel_marker;
    -        rr_wheel_marker.id = 4;
    -        rr_wheel_marker.pose.position.x = vehicle_pose_.pose.position.x - wheelbase * cos(yaw) + track_width/2 * sin(yaw);
    -        rr_wheel_marker.pose.position.y = vehicle_pose_.pose.position.y - wheelbase * sin(yaw) - track_width/2 * cos(yaw);
    -        rr_wheel_marker.pose.orientation = tf2::toMsg(q_lr);
    -        
    -        marker_array.markers.push_back(rr_wheel_marker);
    -        
    -        // 发布标记
    -        cmd_vis_pub_->publish(marker_array);
    -    }
    -    
    -    std::unique_ptr<PurePursuitController> controller_;
    -    geometry_msgs::msg::PoseStamped vehicle_pose_;
    -    geometry_msgs::msg::Twist vehicle_velocity_;
    -    
    -    rclcpp::Subscription<auto_msgs::msg::PlanningPath>::SharedPtr path_sub_;
    -    rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr cmd_vis_pub_;
    -    rclcpp::TimerBase::SharedPtr control_timer_;
    +  }
    +
    +  void updateVehicleState(const ControlCommand & cmd)
    +  {
    +    // 获取当前状态
    +    double x = vehicle_pose_.pose.position.x;
    +    double y = vehicle_pose_.pose.position.y;
    +    tf2::Quaternion quat;
    +    tf2::fromMsg(vehicle_pose_.pose.orientation, quat);
    +    double yaw = tf2::impl::getYaw(quat);
    +    double v = vehicle_velocity_.linear.x;
    +
    +    // 时间步长
    +    double dt = 0.05;      // 50ms
    +
    +    // 计算加速度（简化）
    +    double acceleration = cmd.throttle * 2.0 - cmd.brake * 5.0;      // 简单的加速度模型
    +
    +    // 更新速度（考虑最大/最小速度限制）
    +    v += acceleration * dt;
    +    v = std::max(0.0, std::min(v, 10.0));      // 速度范围：0-10 m/s
    +
    +    // 更新位置
    +    double delta = cmd.steering_angle;      // 转向角
    +    double wheelbase = 2.7;      // 车辆轴距
    +
    +    // 自行车模型
    +    double beta = atan(0.5 * tan(delta));      // 侧偏角
    +    double dx = v * cos(yaw + beta) * dt;
    +    double dy = v * sin(yaw + beta) * dt;
    +    double dyaw = v * tan(delta) * cos(beta) / wheelbase * dt;
    +
    +    // 更新位置和方向
    +    x += dx;
    +    y += dy;
    +    yaw += dyaw;
    +
    +    // 规范化角度到[-pi, pi]
    +    while (yaw > M_PI) {yaw -= 2.0 * M_PI;}
    +    while (yaw < -M_PI) {yaw += 2.0 * M_PI;}
    +
    +    // 更新位置
    +    vehicle_pose_.header.stamp = this->now();
    +    vehicle_pose_.pose.position.x = x;
    +    vehicle_pose_.pose.position.y = y;
    +
    +    // 更新方向
    +    tf2::Quaternion q;
    +    q.setRPY(0.0, 0.0, yaw);
    +    vehicle_pose_.pose.orientation = tf2::toMsg(q);
    +
    +    // 更新速度
    +    vehicle_velocity_.linear.x = v * cos(yaw);
    +    vehicle_velocity_.linear.y = v * sin(yaw);
    +    vehicle_velocity_.angular.z = v * tan(delta) / wheelbase;
    +  }
    +
    +  void visualizeControl(const ControlCommand & cmd)
    +  {
    +    visualization_msgs::msg::MarkerArray marker_array;
    +
    +    // 添加车辆标记
    +    visualization_msgs::msg::Marker vehicle_marker;
    +    vehicle_marker.header.frame_id = "map";
    +    vehicle_marker.header.stamp = this->now();
    +    vehicle_marker.ns = "vehicle";
    +    vehicle_marker.id = 0;
    +    vehicle_marker.type = visualization_msgs::msg::Marker::CUBE;
    +    vehicle_marker.action = visualization_msgs::msg::Marker::ADD;
    +
    +    // 设置位置和方向
    +    vehicle_marker.pose = vehicle_pose_.pose;
    +
    +    // 设置车辆大小
    +    vehicle_marker.scale.x = 4.5;      // 长度
    +    vehicle_marker.scale.y = 2.0;      // 宽度
    +    vehicle_marker.scale.z = 1.5;      // 高度
    +
    +    // 设置颜色
    +    vehicle_marker.color.r = 0.2;
    +    vehicle_marker.color.g = 0.2;
    +    vehicle_marker.color.b = 0.8;
    +    vehicle_marker.color.a = 0.8;
    +
    +    marker_array.markers.push_back(vehicle_marker);
    +
    +    // 添加轮子标记
    +    double wheelbase = 2.7;
    +    double track_width = 1.6;
    +
    +    // 前轮（带转向）
    +    double steering_angle = cmd.steering_angle;
    +
    +    // 左前轮
    +    visualization_msgs::msg::Marker lf_wheel_marker;
    +    lf_wheel_marker.header.frame_id = "map";
    +    lf_wheel_marker.header.stamp = this->now();
    +    lf_wheel_marker.ns = "wheels";
    +    lf_wheel_marker.id = 1;
    +    lf_wheel_marker.type = visualization_msgs::msg::Marker::CUBE;
    +    lf_wheel_marker.action = visualization_msgs::msg::Marker::ADD;
    +
    +    // 计算轮子位置（车辆坐标系）
    +    double wheel_x_offset = 1.8;      // 前轮到车辆中心的距离
    +
    +    // 转换到全局坐标系
    +    tf2::Quaternion quat;
    +    tf2::fromMsg(vehicle_pose_.pose.orientation, quat);
    +    double yaw = tf2::impl::getYaw(quat);
    +
    +    lf_wheel_marker.pose = vehicle_pose_.pose;
    +    lf_wheel_marker.pose.position.x += wheel_x_offset * cos(yaw) - track_width / 2 * sin(yaw);
    +    lf_wheel_marker.pose.position.y += wheel_x_offset * sin(yaw) + track_width / 2 * cos(yaw);
    +
    +    // 设置方向（考虑转向）
    +    tf2::Quaternion q_lf;
    +    q_lf.setRPY(0.0, 0.0, yaw + steering_angle);
    +    lf_wheel_marker.pose.orientation = tf2::toMsg(q_lf);
    +
    +    // 设置轮子大小
    +    lf_wheel_marker.scale.x = 0.7;      // 长度
    +    lf_wheel_marker.scale.y = 0.3;      // 宽度
    +    lf_wheel_marker.scale.z = 0.7;      // 高度
    +
    +    // 设置颜色
    +    lf_wheel_marker.color.r = 0.1;
    +    lf_wheel_marker.color.g = 0.1;
    +    lf_wheel_marker.color.b = 0.1;
    +    lf_wheel_marker.color.a = 1.0;
    +
    +    marker_array.markers.push_back(lf_wheel_marker);
    +
    +    // 右前轮
    +    visualization_msgs::msg::Marker rf_wheel_marker = lf_wheel_marker;
    +    rf_wheel_marker.id = 2;
    +    rf_wheel_marker.pose.position.x = vehicle_pose_.pose.position.x + wheel_x_offset * cos(yaw) +
    +      track_width / 2 * sin(yaw);
    +    rf_wheel_marker.pose.position.y = vehicle_pose_.pose.position.y + wheel_x_offset * sin(yaw) -
    +      track_width / 2 * cos(yaw);
    +    rf_wheel_marker.pose.orientation = tf2::toMsg(q_lf);      // 和左前轮一样的转向
    +
    +    marker_array.markers.push_back(rf_wheel_marker);
    +
    +    // 左后轮
    +    visualization_msgs::msg::Marker lr_wheel_marker = lf_wheel_marker;
    +    lr_wheel_marker.id = 3;
    +    lr_wheel_marker.pose.position.x = vehicle_pose_.pose.position.x - wheelbase * cos(yaw) -
    +      track_width / 2 * sin(yaw);
    +    lr_wheel_marker.pose.position.y = vehicle_pose_.pose.position.y - wheelbase * sin(yaw) +
    +      track_width / 2 * cos(yaw);
    +
    +    // 后轮没有转向
    +    tf2::Quaternion q_lr;
    +    q_lr.setRPY(0.0, 0.0, yaw);
    +    lr_wheel_marker.pose.orientation = tf2::toMsg(q_lr);
    +
    +    marker_array.markers.push_back(lr_wheel_marker);
    +
    +    // 右后轮
    +    visualization_msgs::msg::Marker rr_wheel_marker = lr_wheel_marker;
    +    rr_wheel_marker.id = 4;
    +    rr_wheel_marker.pose.position.x = vehicle_pose_.pose.position.x - wheelbase * cos(yaw) +
    +      track_width / 2 * sin(yaw);
    +    rr_wheel_marker.pose.position.y = vehicle_pose_.pose.position.y - wheelbase * sin(yaw) -
    +      track_width / 2 * cos(yaw);
    +    rr_wheel_marker.pose.orientation = tf2::toMsg(q_lr);
    +
    +    marker_array.markers.push_back(rr_wheel_marker);
    +
    +    // 发布标记
    +    cmd_vis_pub_->publish(marker_array);
    +  }
    +
    +  std::unique_ptr<PurePursuitController> controller_;
    +  geometry_msgs::msg::PoseStamped vehicle_pose_;
    +  geometry_msgs::msg::Twist vehicle_velocity_;
    +
    +  rclcpp::Subscription<auto_msgs::msg::PlanningPath>::SharedPtr path_sub_;
    +  rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr cmd_vis_pub_;
    +  rclcpp::TimerBase::SharedPtr control_timer_;
    @@ -257,6 +271,7 @@
    -int main(int argc, char * argv[]) {
    -    rclcpp::init(argc, argv);
    -    auto node = std::make_shared<auto_control::ControllerNode>();
    -    rclcpp::spin(node);
    -    rclcpp::shutdown();
    -    return 0;
    +int main(int argc, char * argv[])
    +{
    +  rclcpp::init(argc, argv);
    +  auto node = std::make_shared<auto_control::ControllerNode>();
    +  rclcpp::spin(node);
    +  rclcpp::shutdown();
    +  return 0;
    
    Code style divergence in file 'src/pure_pursuit_controller.cpp':
    
    --- src/pure_pursuit_controller.cpp
    +++ src/pure_pursuit_controller.cpp.uncrustify
    @@ -12 +12,2 @@
    -namespace auto_control {
    +namespace auto_control
    +{
    @@ -15,13 +16,14 @@
    -    : last_closest_index_(0),
    -      lookahead_distance_(3.0),
    -      wheelbase_(2.7),
    -      max_velocity_(5.0),
    -      speed_p_gain_(0.5),
    -      has_path_(false),
    -      reached_goal_(false) {}
    -
    -void PurePursuitController::setPath(const auto_msgs::msg::PlanningPath& path) {
    -    path_points_ = path.points;
    -    last_closest_index_ = 0;
    -    has_path_ = !path_points_.empty();
    -    reached_goal_ = false;
    +: last_closest_index_(0),
    +  lookahead_distance_(3.0),
    +  wheelbase_(2.7),
    +  max_velocity_(5.0),
    +  speed_p_gain_(0.5),
    +  has_path_(false),
    +  reached_goal_(false) {}
    +
    +void PurePursuitController::setPath(const auto_msgs::msg::PlanningPath & path)
    +{
    +  path_points_ = path.points;
    +  last_closest_index_ = 0;
    +  has_path_ = !path_points_.empty();
    +  reached_goal_ = false;
    @@ -31,124 +33,130 @@
    -    const geometry_msgs::msg::Pose& current_pose,
    -    const geometry_msgs::msg::Twist& current_velocity) {
    -    
    -    if (!has_path_ || path_points_.empty()) {
    -        return ControlCommand(0.0, 0.0, 0.0);
    -    }
    -    
    -    // 寻找当前位置最近的路径点
    -    size_t closest_index = findClosestPointIndex(current_pose);
    -    last_closest_index_ = closest_index;
    -    
    -    // 检查是否到达终点并打印调试信息
    -    if (closest_index >= path_points_.size() - 1) {
    -        double distance_to_goal = calculateDistance(
    -            current_pose.position, path_points_.back().pose.position);
    -        
    -        std::cout << "DEBUG: 距离终点: " << std::fixed << std::setprecision(2) 
    -                  << distance_to_goal << "米" << std::endl;
    -    }
    -    
    -    // 寻找预瞄点
    -    auto [found_lookahead, lookahead_pose] = findLookaheadPoint(current_pose, closest_index);
    -    
    -    // 如果没有找到预瞄点，使用路径上的最后一个点
    -    if (!found_lookahead) {
    -        lookahead_pose = path_points_.back().pose;
    -    }
    -    
    -    // 计算当前车辆航向角
    -    tf2::Quaternion tf2_quat;
    -    tf2::fromMsg(current_pose.orientation, tf2_quat);
    -    double current_yaw = tf2::impl::getYaw(tf2_quat);
    -    
    -    // 计算从当前位置到预瞄点的向量
    -    double dx = lookahead_pose.position.x - current_pose.position.x;
    -    double dy = lookahead_pose.position.y - current_pose.position.y;
    -    
    -    // 将向量从全局坐标系转换到车辆坐标系
    -    // double target_x = dx * cos(-current_yaw) - dy * sin(-current_yaw); // 未使用
    -    double target_y = dx * sin(-current_yaw) + dy * cos(-current_yaw);
    -    
    -    // 计算曲率
    -    double curvature = 2.0 * target_y / (dx * dx + dy * dy);
    -    
    -    // 根据曲率计算转向角
    -    double steering_angle = atan2(wheelbase_ * curvature, 1.0);
    -    
    -    // 限制转向角在合理范围内
    -    steering_angle = std::clamp(steering_angle, -M_PI / 4.0, M_PI / 4.0);
    -    
    -    // 速度控制：根据曲率调整速度
    -    double target_velocity = max_velocity_ * (1.0 - std::abs(curvature) * wheelbase_ / 2.0);
    -    target_velocity = std::max(1.0, target_velocity);  // 确保最小速度为1.0 m/s
    -    
    -    // 简单的P控制器
    -    double current_speed = std::hypot(current_velocity.linear.x, current_velocity.linear.y);
    -    double accel = speed_p_gain_ * (target_velocity - current_speed);
    -    
    -    // 将加速度转换为油门和制动
    -    double throttle = 0.0;
    -    double brake = 0.0;
    -    
    -    if (accel >= 0.0) {
    -        throttle = std::min(accel, 1.0);  // 限制油门在[0,1]范围内
    -        brake = 0.0;
    -    } else {
    -        throttle = 0.0;
    -        brake = std::min(-accel, 1.0);  // 限制制动在[0,1]范围内
    -    }
    -    
    -    // 检查是否到达终点
    -    if (closest_index >= path_points_.size() - 1) {
    -        double distance_to_goal = calculateDistance(
    -            current_pose.position, path_points_.back().pose.position);
    -        
    -        if (distance_to_goal <= 1.0) {  // 修改为 <= 1.0，以包含恰好等于1.0米的情况
    -            reached_goal_ = true;
    -            return ControlCommand(0.0, 0.0, 1.0);  // 到达终点，全力制动
    -        }
    -        // 接近终点（在2米之内），开始减速
    -        else if (distance_to_goal < 2.0) {
    -            // 确保最小制动值足够大，以通过测试
    -            double decel_brake = std::max(0.05, 0.5 * (2.0 - distance_to_goal)); // 增加基础制动值和系数
    -            return ControlCommand(steering_angle, throttle * 0.5, decel_brake);
    -        }
    -    }
    -    
    -    return ControlCommand(steering_angle, throttle, brake);
    -}
    -
    -void PurePursuitController::setLookaheadDistance(double distance) {
    -    lookahead_distance_ = distance;
    -}
    -
    -void PurePursuitController::setMaxVelocity(double velocity) {
    -    max_velocity_ = velocity;
    -}
    -
    -bool PurePursuitController::hasPath() const {
    -    return has_path_;
    -}
    -
    -bool PurePursuitController::reachedGoal() const {
    -    return reached_goal_;
    -}
    -
    -size_t PurePursuitController::findClosestPointIndex(const geometry_msgs::msg::Pose& pose) {
    -    if (path_points_.empty()) {
    -        return 0;
    -    }
    -    
    -    size_t closest_index = last_closest_index_;
    -    double min_dist = std::numeric_limits<double>::max();
    -    
    -    // 从上次最近点开始搜索，避免向后找
    -    for (size_t i = last_closest_index_; i < path_points_.size(); ++i) {
    -        double dist = calculateDistance(pose.position, path_points_[i].pose.position);
    -        if (dist < min_dist) {
    -            min_dist = dist;
    -            closest_index = i;
    -        }
    -    }
    -    
    -    return closest_index;
    +  const geometry_msgs::msg::Pose & current_pose,
    +  const geometry_msgs::msg::Twist & current_velocity)
    +{
    +
    +  if (!has_path_ || path_points_.empty()) {
    +    return ControlCommand(0.0, 0.0, 0.0);
    +  }
    +
    +  // 寻找当前位置最近的路径点
    +  size_t closest_index = findClosestPointIndex(current_pose);
    +  last_closest_index_ = closest_index;
    +
    +  // 检查是否到达终点并打印调试信息
    +  if (closest_index >= path_points_.size() - 1) {
    +    double distance_to_goal = calculateDistance(
    +      current_pose.position, path_points_.back().pose.position);
    +
    +    std::cout << "DEBUG: 距离终点: " << std::fixed << std::setprecision(2)
    +              << distance_to_goal << "米" << std::endl;
    +  }
    +
    +  // 寻找预瞄点
    +  auto [found_lookahead, lookahead_pose] = findLookaheadPoint(current_pose, closest_index);
    +
    +  // 如果没有找到预瞄点，使用路径上的最后一个点
    +  if (!found_lookahead) {
    +    lookahead_pose = path_points_.back().pose;
    +  }
    +
    +  // 计算当前车辆航向角
    +  tf2::Quaternion tf2_quat;
    +  tf2::fromMsg(current_pose.orientation, tf2_quat);
    +  double current_yaw = tf2::impl::getYaw(tf2_quat);
    +
    +  // 计算从当前位置到预瞄点的向量
    +  double dx = lookahead_pose.position.x - current_pose.position.x;
    +  double dy = lookahead_pose.position.y - current_pose.position.y;
    +
    +  // 将向量从全局坐标系转换到车辆坐标系
    +  // double target_x = dx * cos(-current_yaw) - dy * sin(-current_yaw); // 未使用
    +  double target_y = dx * sin(-current_yaw) + dy * cos(-current_yaw);
    +
    +  // 计算曲率
    +  double curvature = 2.0 * target_y / (dx * dx + dy * dy);
    +
    +  // 根据曲率计算转向角
    +  double steering_angle = atan2(wheelbase_ * curvature, 1.0);
    +
    +  // 限制转向角在合理范围内
    +  steering_angle = std::clamp(steering_angle, -M_PI / 4.0, M_PI / 4.0);
    +
    +  // 速度控制：根据曲率调整速度
    +  double target_velocity = max_velocity_ * (1.0 - std::abs(curvature) * wheelbase_ / 2.0);
    +  target_velocity = std::max(1.0, target_velocity);    // 确保最小速度为1.0 m/s
    +
    +  // 简单的P控制器
    +  double current_speed = std::hypot(current_velocity.linear.x, current_velocity.linear.y);
    +  double accel = speed_p_gain_ * (target_velocity - current_speed);
    +
    +  // 将加速度转换为油门和制动
    +  double throttle = 0.0;
    +  double brake = 0.0;
    +
    +  if (accel >= 0.0) {
    +    throttle = std::min(accel, 1.0);      // 限制油门在[0,1]范围内
    +    brake = 0.0;
    +  } else {
    +    throttle = 0.0;
    +    brake = std::min(-accel, 1.0);      // 限制制动在[0,1]范围内
    +  }
    +
    +  // 检查是否到达终点
    +  if (closest_index >= path_points_.size() - 1) {
    +    double distance_to_goal = calculateDistance(
    +      current_pose.position, path_points_.back().pose.position);
    +
    +    if (distance_to_goal <= 1.0) {      // 修改为 <= 1.0，以包含恰好等于1.0米的情况
    +      reached_goal_ = true;
    +      return ControlCommand(0.0, 0.0, 1.0);        // 到达终点，全力制动
    +    }
    +    // 接近终点（在2米之内），开始减速
    +    else if (distance_to_goal < 2.0) {
    +      // 确保最小制动值足够大，以通过测试
    +      double decel_brake = std::max(0.05, 0.5 * (2.0 - distance_to_goal));       // 增加基础制动值和系数
    +      return ControlCommand(steering_angle, throttle * 0.5, decel_brake);
    +    }
    +  }
    +
    +  return ControlCommand(steering_angle, throttle, brake);
    +}
    +
    +void PurePursuitController::setLookaheadDistance(double distance)
    +{
    +  lookahead_distance_ = distance;
    +}
    +
    +void PurePursuitController::setMaxVelocity(double velocity)
    +{
    +  max_velocity_ = velocity;
    +}
    +
    +bool PurePursuitController::hasPath() const
    +{
    +  return has_path_;
    +}
    +
    +bool PurePursuitController::reachedGoal() const
    +{
    +  return reached_goal_;
    +}
    +
    +size_t PurePursuitController::findClosestPointIndex(const geometry_msgs::msg::Pose & pose)
    +{
    +  if (path_points_.empty()) {
    +    return 0;
    +  }
    +
    +  size_t closest_index = last_closest_index_;
    +  double min_dist = std::numeric_limits<double>::max();
    +
    +  // 从上次最近点开始搜索，避免向后找
    +  for (size_t i = last_closest_index_; i < path_points_.size(); ++i) {
    +    double dist = calculateDistance(pose.position, path_points_[i].pose.position);
    +    if (dist < min_dist) {
    +      min_dist = dist;
    +      closest_index = i;
    +    }
    +  }
    +
    +  return closest_index;
    @@ -158,53 +166,54 @@
    -    const geometry_msgs::msg::Pose& pose, size_t start_index) {
    -    
    -    if (path_points_.empty() || start_index >= path_points_.size()) {
    -        return {false, geometry_msgs::msg::Pose()};
    -    }
    -    
    -    // 首先尝试在路径上找到一个距离当前位置正好是预瞄距离的点
    -    for (size_t i = start_index; i < path_points_.size() - 1; ++i) {
    -        geometry_msgs::msg::Point p1 = path_points_[i].pose.position;
    -        geometry_msgs::msg::Point p2 = path_points_[i + 1].pose.position;
    -        
    -        geometry_msgs::msg::Point v1;
    -        v1.x = p1.x - pose.position.x;
    -        v1.y = p1.y - pose.position.y;
    -        
    -        geometry_msgs::msg::Point v2;
    -        v2.x = p2.x - pose.position.x;
    -        v2.y = p2.y - pose.position.y;
    -        
    -        double d1 = std::hypot(v1.x, v1.y);
    -        double d2 = std::hypot(v2.x, v2.y);
    -        
    -        if (d1 <= lookahead_distance_ && d2 >= lookahead_distance_) {
    -            // 通过线性插值找到路径上距离正好是lookahead_distance_的点
    -            double t = (lookahead_distance_ - d1) / (d2 - d1);
    -            
    -            geometry_msgs::msg::Pose lookahead_pose;
    -            lookahead_pose.position.x = p1.x + t * (p2.x - p1.x);
    -            lookahead_pose.position.y = p1.y + t * (p2.y - p1.y);
    -            lookahead_pose.position.z = p1.z + t * (p2.z - p1.z);
    -            
    -            // 简单地使用插值计算方向
    -            tf2::Quaternion q1, q2;
    -            tf2::fromMsg(path_points_[i].pose.orientation, q1);
    -            tf2::fromMsg(path_points_[i + 1].pose.orientation, q2);
    -            double yaw1 = tf2::impl::getYaw(q1);
    -            double yaw2 = tf2::impl::getYaw(q2);
    -            double yaw = yaw1 + t * (yaw2 - yaw1);
    -            
    -            tf2::Quaternion q;
    -            q.setRPY(0, 0, yaw);
    -            lookahead_pose.orientation.x = q.x();
    -            lookahead_pose.orientation.y = q.y();
    -            lookahead_pose.orientation.z = q.z();
    -            lookahead_pose.orientation.w = q.w();
    -            
    -            return {true, lookahead_pose};
    -        }
    -    }
    -    
    -    // 如果没有找到合适的点，使用路径上最远的点
    -    size_t furthest_index = std::min(start_index + 10, path_points_.size() - 1);
    -    return {true, path_points_[furthest_index].pose};
    +  const geometry_msgs::msg::Pose & pose, size_t start_index)
    +{
    +
    +  if (path_points_.empty() || start_index >= path_points_.size()) {
    +    return {false, geometry_msgs::msg::Pose()};
    +  }
    +
    +  // 首先尝试在路径上找到一个距离当前位置正好是预瞄距离的点
    +  for (size_t i = start_index; i < path_points_.size() - 1; ++i) {
    +    geometry_msgs::msg::Point p1 = path_points_[i].pose.position;
    +    geometry_msgs::msg::Point p2 = path_points_[i + 1].pose.position;
    +
    +    geometry_msgs::msg::Point v1;
    +    v1.x = p1.x - pose.position.x;
    +    v1.y = p1.y - pose.position.y;
    +
    +    geometry_msgs::msg::Point v2;
    +    v2.x = p2.x - pose.position.x;
    +    v2.y = p2.y - pose.position.y;
    +
    +    double d1 = std::hypot(v1.x, v1.y);
    +    double d2 = std::hypot(v2.x, v2.y);
    +
    +    if (d1 <= lookahead_distance_ && d2 >= lookahead_distance_) {
    +      // 通过线性插值找到路径上距离正好是lookahead_distance_的点
    +      double t = (lookahead_distance_ - d1) / (d2 - d1);
    +
    +      geometry_msgs::msg::Pose lookahead_pose;
    +      lookahead_pose.position.x = p1.x + t * (p2.x - p1.x);
    +      lookahead_pose.position.y = p1.y + t * (p2.y - p1.y);
    +      lookahead_pose.position.z = p1.z + t * (p2.z - p1.z);
    +
    +      // 简单地使用插值计算方向
    +      tf2::Quaternion q1, q2;
    +      tf2::fromMsg(path_points_[i].pose.orientation, q1);
    +      tf2::fromMsg(path_points_[i + 1].pose.orientation, q2);
    +      double yaw1 = tf2::impl::getYaw(q1);
    +      double yaw2 = tf2::impl::getYaw(q2);
    +      double yaw = yaw1 + t * (yaw2 - yaw1);
    +
    +      tf2::Quaternion q;
    +      q.setRPY(0, 0, yaw);
    +      lookahead_pose.orientation.x = q.x();
    +      lookahead_pose.orientation.y = q.y();
    +      lookahead_pose.orientation.z = q.z();
    +      lookahead_pose.orientation.w = q.w();
    +
    +      return {true, lookahead_pose};
    +    }
    +  }
    +
    +  // 如果没有找到合适的点，使用路径上最远的点
    +  size_t furthest_index = std::min(start_index + 10, path_points_.size() - 1);
    +  return {true, path_points_[furthest_index].pose};
    @@ -214,4 +223,5 @@
    -    const geometry_msgs::msg::Point& p1, 
    -    const geometry_msgs::msg::Point& p2) {
    -    
    -    return std::hypot(p2.x - p1.x, p2.y - p1.y);
    +  const geometry_msgs::msg::Point & p1,
    +  const geometry_msgs::msg::Point & p2)
    +{
    +
    +  return std::hypot(p2.x - p1.x, p2.y - p1.y);
    
    Code style divergence in file 'test/test_controller.cpp':
    
    --- test/test_controller.cpp
    +++ test/test_controller.cpp.uncrustify
    @@ -19,32 +19,70 @@
    -auto_msgs::msg::PlanningPath createStraightPath(double start_x, double start_y, double end_x, double end_y, int num_points = 10) {
    -    auto_msgs::msg::PlanningPath path;
    -    path.header.frame_id = "map";
    -    path.planner_type = "test";
    -    path.total_distance = std::hypot(end_x - start_x, end_y - start_y);
    -    
    -    // 在起点和终点之间均匀插入点
    -    for (int i = 0; i < num_points; ++i) {
    -        double t = static_cast<double>(i) / (num_points - 1);
    -        double x = start_x + t * (end_x - start_x);
    -        double y = start_y + t * (end_y - start_y);
    -        
    -        auto_msgs::msg::PathPoint point;
    -        point.pose.position.x = x;
    -        point.pose.position.y = y;
    -        point.pose.position.z = 0.0;
    -        
    -        // 计算方向（假设路径方向沿着直线）
    -        double yaw = std::atan2(end_y - start_y, end_x - start_x);
    -        tf2::Quaternion q;
    -        q.setRPY(0.0, 0.0, yaw);
    -        point.pose.orientation.x = q.x();
    -        point.pose.orientation.y = q.y();
    -        point.pose.orientation.z = q.z();
    -        point.pose.orientation.w = q.w();
    -        
    -        // 设置其他属性
    -        point.velocity = 2.0;  // 假设恒定速度
    -        point.steering_angle = 0.0;  // 直线路径，转向角为0
    -        point.curvature = 0.0;  // 直线路径，曲率为0
    -        
    -        path.points.push_back(point);
    +auto_msgs::msg::PlanningPath createStraightPath(
    +  double start_x, double start_y, double end_x,
    +  double end_y, int num_points = 10)
    +{
    +  auto_msgs::msg::PlanningPath path;
    +  path.header.frame_id = "map";
    +  path.planner_type = "test";
    +  path.total_distance = std::hypot(end_x - start_x, end_y - start_y);
    +
    +  // 在起点和终点之间均匀插入点
    +  for (int i = 0; i < num_points; ++i) {
    +    double t = static_cast<double>(i) / (num_points - 1);
    +    double x = start_x + t * (end_x - start_x);
    +    double y = start_y + t * (end_y - start_y);
    +
    +    auto_msgs::msg::PathPoint point;
    +    point.pose.position.x = x;
    +    point.pose.position.y = y;
    +    point.pose.position.z = 0.0;
    +
    +    // 计算方向（假设路径方向沿着直线）
    +    double yaw = std::atan2(end_y - start_y, end_x - start_x);
    +    tf2::Quaternion q;
    +    q.setRPY(0.0, 0.0, yaw);
    +    point.pose.orientation.x = q.x();
    +    point.pose.orientation.y = q.y();
    +    point.pose.orientation.z = q.z();
    +    point.pose.orientation.w = q.w();
    +
    +    // 设置其他属性
    +    point.velocity = 2.0;      // 假设恒定速度
    +    point.steering_angle = 0.0;      // 直线路径，转向角为0
    +    point.curvature = 0.0;      // 直线路径，曲率为0
    +
    +    path.points.push_back(point);
    +  }
    +
    +  return path;
    +}
    +
    +// 创建一个简单的圆弧路径进行测试
    +auto_msgs::msg::PlanningPath createCurvedPath(
    +  double center_x, double center_y, double radius,
    +  double start_angle, double end_angle,
    +  int num_points = 10)
    +{
    +  auto_msgs::msg::PlanningPath path;
    +  path.header.frame_id = "map";
    +  path.planner_type = "test";
    +
    +  // 计算弧长
    +  double arc_length = radius * std::abs(end_angle - start_angle);
    +  path.total_distance = arc_length;
    +
    +  // 在起始角度和结束角度之间均匀插入点
    +  for (int i = 0; i < num_points; ++i) {
    +    double t = static_cast<double>(i) / (num_points - 1);
    +    double angle = start_angle + t * (end_angle - start_angle);
    +    double x = center_x + radius * std::cos(angle);
    +    double y = center_y + radius * std::sin(angle);
    +
    +    auto_msgs::msg::PathPoint point;
    +    point.pose.position.x = x;
    +    point.pose.position.y = y;
    +    point.pose.position.z = 0.0;
    +
    +    // 计算切线方向（垂直于半径方向）
    +    double yaw = angle + M_PI / 2.0;
    +    if (end_angle < start_angle) {
    +      yaw = angle - M_PI / 2.0;        // 顺时针方向
    @@ -52,48 +90,17 @@
    -    
    -    return path;
    -}
    -
    -// 创建一个简单的圆弧路径进行测试
    -auto_msgs::msg::PlanningPath createCurvedPath(double center_x, double center_y, double radius, double start_angle, double end_angle, int num_points = 10) {
    -    auto_msgs::msg::PlanningPath path;
    -    path.header.frame_id = "map";
    -    path.planner_type = "test";
    -    
    -    // 计算弧长
    -    double arc_length = radius * std::abs(end_angle - start_angle);
    -    path.total_distance = arc_length;
    -    
    -    // 在起始角度和结束角度之间均匀插入点
    -    for (int i = 0; i < num_points; ++i) {
    -        double t = static_cast<double>(i) / (num_points - 1);
    -        double angle = start_angle + t * (end_angle - start_angle);
    -        double x = center_x + radius * std::cos(angle);
    -        double y = center_y + radius * std::sin(angle);
    -        
    -        auto_msgs::msg::PathPoint point;
    -        point.pose.position.x = x;
    -        point.pose.position.y = y;
    -        point.pose.position.z = 0.0;
    -        
    -        // 计算切线方向（垂直于半径方向）
    -        double yaw = angle + M_PI / 2.0;
    -        if (end_angle < start_angle) {
    -            yaw = angle - M_PI / 2.0;  // 顺时针方向
    -        }
    -        
    -        tf2::Quaternion q;
    -        q.setRPY(0.0, 0.0, yaw);
    -        point.pose.orientation.x = q.x();
    -        point.pose.orientation.y = q.y();
    -        point.pose.orientation.z = q.z();
    -        point.pose.orientation.w = q.w();
    -        
    -        // 设置其他属性
    -        point.velocity = 2.0;  // 假设恒定速度
    -        point.steering_angle = 0.0;  // 将在控制器中计算
    -        point.curvature = 1.0 / radius;  // 曲率为半径的倒数
    -        
    -        path.points.push_back(point);
    -    }
    -    
    -    return path;
    +
    +    tf2::Quaternion q;
    +    q.setRPY(0.0, 0.0, yaw);
    +    point.pose.orientation.x = q.x();
    +    point.pose.orientation.y = q.y();
    +    point.pose.orientation.z = q.z();
    +    point.pose.orientation.w = q.w();
    +
    +    // 设置其他属性
    +    point.velocity = 2.0;      // 假设恒定速度
    +    point.steering_angle = 0.0;      // 将在控制器中计算
    +    point.curvature = 1.0 / radius;      // 曲率为半径的倒数
    +
    +    path.points.push_back(point);
    +  }
    +
    +  return path;
    @@ -104,40 +111,40 @@
    -    // 创建控制器
    -    auto_control::PurePursuitController controller;
    -    controller.setLookaheadDistance(2.0);
    -    controller.setMaxVelocity(5.0);
    -    
    -    // 创建一条简单的直线路径
    -    auto path = createStraightPath(0.0, 0.0, 10.0, 0.0, 20);
    -    controller.setPath(path);
    -    
    -    // 测试控制器状态
    -    EXPECT_TRUE(controller.hasPath());
    -    EXPECT_FALSE(controller.reachedGoal());
    -    
    -    // 创建当前位置（在路径起点附近，但有一点偏移）
    -    geometry_msgs::msg::Pose current_pose;
    -    current_pose.position.x = 0.0;
    -    current_pose.position.y = 0.5;  // 稍微偏离路径
    -    current_pose.position.z = 0.0;
    -    tf2::Quaternion q;
    -    q.setRPY(0.0, 0.0, 0.0);  // 朝向x轴正方向
    -    current_pose.orientation.x = q.x();
    -    current_pose.orientation.y = q.y();
    -    current_pose.orientation.z = q.z();
    -    current_pose.orientation.w = q.w();
    -    
    -    // 创建当前速度（初始静止）
    -    geometry_msgs::msg::Twist current_velocity;
    -    current_velocity.linear.x = 0.0;
    -    current_velocity.linear.y = 0.0;
    -    current_velocity.angular.z = 0.0;
    -    
    -    // 计算控制命令
    -    auto cmd = controller.calculateControl(current_pose, current_velocity);
    -    
    -    // 验证控制命令
    -    // 由于偏离路径在左侧，应该向右转向（负转向角）
    -    EXPECT_LT(cmd.steering_angle, 0.0);
    -    // 应该有油门，没有制动
    -    EXPECT_GT(cmd.throttle, 0.0);
    -    EXPECT_EQ(cmd.brake, 0.0);
    +  // 创建控制器
    +  auto_control::PurePursuitController controller;
    +  controller.setLookaheadDistance(2.0);
    +  controller.setMaxVelocity(5.0);
    +
    +  // 创建一条简单的直线路径
    +  auto path = createStraightPath(0.0, 0.0, 10.0, 0.0, 20);
    +  controller.setPath(path);
    +
    +  // 测试控制器状态
    +  EXPECT_TRUE(controller.hasPath());
    +  EXPECT_FALSE(controller.reachedGoal());
    +
    +  // 创建当前位置（在路径起点附近，但有一点偏移）
    +  geometry_msgs::msg::Pose current_pose;
    +  current_pose.position.x = 0.0;
    +  current_pose.position.y = 0.5;    // 稍微偏离路径
    +  current_pose.position.z = 0.0;
    +  tf2::Quaternion q;
    +  q.setRPY(0.0, 0.0, 0.0);    // 朝向x轴正方向
    +  current_pose.orientation.x = q.x();
    +  current_pose.orientation.y = q.y();
    +  current_pose.orientation.z = q.z();
    +  current_pose.orientation.w = q.w();
    +
    +  // 创建当前速度（初始静止）
    +  geometry_msgs::msg::Twist current_velocity;
    +  current_velocity.linear.x = 0.0;
    +  current_velocity.linear.y = 0.0;
    +  current_velocity.angular.z = 0.0;
    +
    +  // 计算控制命令
    +  auto cmd = controller.calculateControl(current_pose, current_velocity);
    +
    +  // 验证控制命令
    +  // 由于偏离路径在左侧，应该向右转向（负转向角）
    +  EXPECT_LT(cmd.steering_angle, 0.0);
    +  // 应该有油门，没有制动
    +  EXPECT_GT(cmd.throttle, 0.0);
    +  EXPECT_EQ(cmd.brake, 0.0);
    @@ -148,33 +155,33 @@
    -    // 创建控制器
    -    auto_control::PurePursuitController controller;
    -    controller.setLookaheadDistance(2.0);
    -    controller.setMaxVelocity(5.0);
    -    
    -    // 创建一条简单的直线路径
    -    auto path = createStraightPath(0.0, 0.0, 10.0, 0.0, 20);
    -    controller.setPath(path);
    -    
    -    // 创建当前位置（非常接近终点）
    -    geometry_msgs::msg::Pose current_pose;
    -    current_pose.position.x = 8.5;  // 明确设置在终点(10.0, 0.0)之前1.5米，确保在制动区间内
    -    current_pose.position.y = 0.0;
    -    current_pose.position.z = 0.0;
    -    tf2::Quaternion q;
    -    q.setRPY(0.0, 0.0, 0.0);  // 朝向x轴正方向
    -    current_pose.orientation.x = q.x();
    -    current_pose.orientation.y = q.y();
    -    current_pose.orientation.z = q.z();
    -    current_pose.orientation.w = q.w();
    -    
    -    // 创建当前速度（已经在移动）
    -    geometry_msgs::msg::Twist current_velocity;
    -    current_velocity.linear.x = 2.0;
    -    current_velocity.linear.y = 0.0;
    -    current_velocity.angular.z = 0.0;
    -    
    -    // 计算控制命令
    -    auto cmd = controller.calculateControl(current_pose, current_velocity);
    -    
    -    // 验证控制命令
    -    // 应该有制动，因为接近终点
    -    EXPECT_GT(cmd.brake, 0.0);
    +  // 创建控制器
    +  auto_control::PurePursuitController controller;
    +  controller.setLookaheadDistance(2.0);
    +  controller.setMaxVelocity(5.0);
    +
    +  // 创建一条简单的直线路径
    +  auto path = createStraightPath(0.0, 0.0, 10.0, 0.0, 20);
    +  controller.setPath(path);
    +
    +  // 创建当前位置（非常接近终点）
    +  geometry_msgs::msg::Pose current_pose;
    +  current_pose.position.x = 8.5;    // 明确设置在终点(10.0, 0.0)之前1.5米，确保在制动区间内
    +  current_pose.position.y = 0.0;
    +  current_pose.position.z = 0.0;
    +  tf2::Quaternion q;
    +  q.setRPY(0.0, 0.0, 0.0);    // 朝向x轴正方向
    +  current_pose.orientation.x = q.x();
    +  current_pose.orientation.y = q.y();
    +  current_pose.orientation.z = q.z();
    +  current_pose.orientation.w = q.w();
    +
    +  // 创建当前速度（已经在移动）
    +  geometry_msgs::msg::Twist current_velocity;
    +  current_velocity.linear.x = 2.0;
    +  current_velocity.linear.y = 0.0;
    +  current_velocity.angular.z = 0.0;
    +
    +  // 计算控制命令
    +  auto cmd = controller.calculateControl(current_pose, current_velocity);
    +
    +  // 验证控制命令
    +  // 应该有制动，因为接近终点
    +  EXPECT_GT(cmd.brake, 0.0);
    @@ -185,41 +192,42 @@
    -    // 创建控制器
    -    auto_control::PurePursuitController controller;
    -    controller.setLookaheadDistance(3.0);
    -    controller.setMaxVelocity(5.0);
    -    
    -    // 创建一条圆弧路径（顺时针90度转弯）
    -    auto path = createCurvedPath(10.0, 0.0, 10.0, M_PI, M_PI / 2.0, 20);
    -    controller.setPath(path);
    -    
    -    // 创建当前位置（在圆弧起点）
    -    geometry_msgs::msg::Pose current_pose;
    -    current_pose.position.x = 0.0;  // 圆心(10, 0)，半径10，起始角度π，所以位置是(0, 0)
    -    current_pose.position.y = 0.0;
    -    current_pose.position.z = 0.0;
    -    tf2::Quaternion q;
    -    q.setRPY(0.0, 0.0, M_PI / 2.0);  // 朝向y轴正方向
    -    current_pose.orientation.x = q.x();
    -    current_pose.orientation.y = q.y();
    -    current_pose.orientation.z = q.z();
    -    current_pose.orientation.w = q.w();
    -    
    -    // 创建当前速度
    -    geometry_msgs::msg::Twist current_velocity;
    -    current_velocity.linear.x = 0.0;
    -    current_velocity.linear.y = 2.0;  // 沿y轴正方向移动
    -    current_velocity.angular.z = 0.0;
    -    
    -    // 计算控制命令
    -    auto cmd = controller.calculateControl(current_pose, current_velocity);
    -    
    -    // 验证控制命令
    -    // 应该向右转向（负转向角）来跟随顺时针圆弧
    -    EXPECT_LT(cmd.steering_angle, 0.0);
    -    // 应该有油门，因为我们刚开始沿着新路径
    -    EXPECT_GT(cmd.throttle, 0.0);
    -}
    -
    -int main(int argc, char **argv) {
    -    testing::InitGoogleTest(&argc, argv);
    -    return RUN_ALL_TESTS();
    -}
    +  // 创建控制器
    +  auto_control::PurePursuitController controller;
    +  controller.setLookaheadDistance(3.0);
    +  controller.setMaxVelocity(5.0);
    +
    +  // 创建一条圆弧路径（顺时针90度转弯）
    +  auto path = createCurvedPath(10.0, 0.0, 10.0, M_PI, M_PI / 2.0, 20);
    +  controller.setPath(path);
    +
    +  // 创建当前位置（在圆弧起点）
    +  geometry_msgs::msg::Pose current_pose;
    +  current_pose.position.x = 0.0;    // 圆心(10, 0)，半径10，起始角度π，所以位置是(0, 0)
    +  current_pose.position.y = 0.0;
    +  current_pose.position.z = 0.0;
    +  tf2::Quaternion q;
    +  q.setRPY(0.0, 0.0, M_PI / 2.0);    // 朝向y轴正方向
    +  current_pose.orientation.x = q.x();
    +  current_pose.orientation.y = q.y();
    +  current_pose.orientation.z = q.z();
    +  current_pose.orientation.w = q.w();
    +
    +  // 创建当前速度
    +  geometry_msgs::msg::Twist current_velocity;
    +  current_velocity.linear.x = 0.0;
    +  current_velocity.linear.y = 2.0;    // 沿y轴正方向移动
    +  current_velocity.angular.z = 0.0;
    +
    +  // 计算控制命令
    +  auto cmd = controller.calculateControl(current_pose, current_velocity);
    +
    +  // 验证控制命令
    +  // 应该向右转向（负转向角）来跟随顺时针圆弧
    +  EXPECT_LT(cmd.steering_angle, 0.0);
    +  // 应该有油门，因为我们刚开始沿着新路径
    +  EXPECT_GT(cmd.throttle, 0.0);
    +}
    +
    +int main(int argc, char ** argv)
    +{
    +  testing::InitGoogleTest(&argc, argv);
    +  return RUN_ALL_TESTS();
    +}
    
    4 files with code style divergence
    -- run_test.py: return code 1
    -- run_test.py: verify result file '/home/onion/samples/autonomous_driving_ws/build/auto_control/test_results/auto_control/uncrustify.xunit.xml'
  >>>
build/auto_control/test_results/auto_control/test_controller.gtest.xml: 3 tests, 0 errors, 1 failure, 0 skipped
- auto_control.ControllerTest ApproachGoalTest
  <<< failure message
    /home/onion/samples/autonomous_driving_ws/src/auto_control/test/test_controller.cpp:180
    Expected: (cmd.brake) > (0.0), actual: 0 vs 0
  >>>
build/auto_control/test_results/auto_control/uncrustify.xunit.xml: 4 tests, 0 errors, 4 failures, 0 skipped
- auto_control.uncrustify include/auto_control/pure_pursuit_controller.hpp
  <<< failure message
    Diff with 141 lines
  >>>
- auto_control.uncrustify src/controller_node.cpp
  <<< failure message
    Diff with 494 lines
  >>>
- auto_control.uncrustify src/pure_pursuit_controller.cpp
  <<< failure message
    Diff with 407 lines
  >>>
- auto_control.uncrustify test/test_controller.cpp
  <<< failure message
    Diff with 403 lines
  >>>
build/auto_perception/Testing/20250526-0636/Test.xml: 4 tests, 0 errors, 2 failures, 0 skipped
- lint_cmake
  <<< failure message
    -- run_test.py: invoking following command in '/home/onion/samples/autonomous_driving_ws/src/auto_perception':
     - /opt/ros/humble/bin/ament_lint_cmake --xunit-file /home/onion/samples/autonomous_driving_ws/build/auto_perception/test_results/auto_perception/lint_cmake.xunit.xml
    CMakeLists.txt:64: Line ends in whitespace [whitespace/eol]
    
    
    1 errors
    -- run_test.py: return code 1
    -- run_test.py: verify result file '/home/onion/samples/autonomous_driving_ws/build/auto_perception/test_results/auto_perception/lint_cmake.xunit.xml'
  >>>
- uncrustify
  <<< failure message
    -- run_test.py: invoking following command in '/home/onion/samples/autonomous_driving_ws/src/auto_perception':
     - /opt/ros/humble/bin/ament_uncrustify --xunit-file /home/onion/samples/autonomous_driving_ws/build/auto_perception/test_results/auto_perception/uncrustify.xunit.xml
    Code style divergence in file 'include/auto_perception/object_detector.hpp':
    
    --- include/auto_perception/object_detector.hpp
    +++ include/auto_perception/object_detector.hpp.uncrustify
    @@ -10 +10,2 @@
    -namespace auto_perception {
    +namespace auto_perception
    +{
    @@ -12,19 +13,20 @@
    -struct DetectedObject {
    -    int id;
    -    geometry_msgs::msg::Pose pose;
    -    double width;
    -    double length;
    -    double height;
    -    std::string classification;
    -    double confidence;
    -    
    -    DetectedObject(
    -        int id_,
    -        const geometry_msgs::msg::Pose& pose_,
    -        double width_ = 1.0,
    -        double length_ = 1.0,
    -        double height_ = 1.0,
    -        const std::string& classification_ = "unknown",
    -        double confidence_ = 1.0)
    -        : id(id_), pose(pose_), width(width_), length(length_), height(height_), 
    -          classification(classification_), confidence(confidence_) {}
    +struct DetectedObject
    +{
    +  int id;
    +  geometry_msgs::msg::Pose pose;
    +  double width;
    +  double length;
    +  double height;
    +  std::string classification;
    +  double confidence;
    +
    +  DetectedObject(
    +    int id_,
    +    const geometry_msgs::msg::Pose & pose_,
    +    double width_ = 1.0,
    +    double length_ = 1.0,
    +    double height_ = 1.0,
    +    const std::string & classification_ = "unknown",
    +    double confidence_ = 1.0)
    +  : id(id_), pose(pose_), width(width_), length(length_), height(height_),
    +    classification(classification_), confidence(confidence_) {}
    @@ -33 +35,2 @@
    -class ObjectDetector {
    +class ObjectDetector
    +{
    @@ -35,2 +38,2 @@
    -    ObjectDetector();
    -    virtual ~ObjectDetector() = default;
    +  ObjectDetector();
    +  virtual ~ObjectDetector() = default;
    @@ -38,5 +41,6 @@
    -    // 从网格地图中检测障碍物
    -    std::vector<DetectedObject> detectObjects(const auto_msgs::msg::GridMap& map);
    -    
    -    // 可视化检测到的障碍物
    -    visualization_msgs::msg::MarkerArray visualizeObjects(const std::vector<DetectedObject>& objects);
    +  // 从网格地图中检测障碍物
    +  std::vector<DetectedObject> detectObjects(const auto_msgs::msg::GridMap & map);
    +
    +  // 可视化检测到的障碍物
    +  visualization_msgs::msg::MarkerArray visualizeObjects(
    +    const std::vector<DetectedObject> & objects);
    @@ -45,9 +49,3 @@
    -    // 查找连接的组件（障碍物聚类）
    -    std::vector<std::vector<std::pair<int, int>>> findConnectedComponents(
    -        const auto_msgs::msg::GridMap& map);
    -        
    -    // 获取障碍物的中心位置和大小
    -    DetectedObject componentToObject(
    -        const std::vector<std::pair<int, int>>& component,
    -        const auto_msgs::msg::GridMap& map,
    -        int id);
    +  // 查找连接的组件（障碍物聚类）
    +  std::vector<std::vector<std::pair<int, int>>> findConnectedComponents(
    +    const auto_msgs::msg::GridMap & map);
    @@ -55 +53,7 @@
    -    int next_object_id_;
    +  // 获取障碍物的中心位置和大小
    +  DetectedObject componentToObject(
    +    const std::vector<std::pair<int, int>> & component,
    +    const auto_msgs::msg::GridMap & map,
    +    int id);
    +
    +  int next_object_id_;
    
    Code style divergence in file 'src/object_detector.cpp':
    
    --- src/object_detector.cpp
    +++ src/object_detector.cpp.uncrustify
    @@ -10,16 +10,73 @@
    -namespace auto_perception {
    -
    -ObjectDetector::ObjectDetector() : next_object_id_(1) {}
    -
    -std::vector<DetectedObject> ObjectDetector::detectObjects(const auto_msgs::msg::GridMap& map) {
    -    // 获取连接的组件（潜在的障碍物）
    -    auto components = findConnectedComponents(map);
    -    
    -    std::vector<DetectedObject> objects;
    -    objects.reserve(components.size());
    -    
    -    // 将每个组件转换为检测到的对象
    -    for (const auto& component : components) {
    -        if (component.size() > 3) {  // 过滤掉太小的组件（可能是噪声）
    -            auto object = componentToObject(component, map, next_object_id_++);
    -            objects.push_back(object);
    +namespace auto_perception
    +{
    +
    +ObjectDetector::ObjectDetector()
    +: next_object_id_(1) {}
    +
    +std::vector<DetectedObject> ObjectDetector::detectObjects(const auto_msgs::msg::GridMap & map)
    +{
    +  // 获取连接的组件（潜在的障碍物）
    +  auto components = findConnectedComponents(map);
    +
    +  std::vector<DetectedObject> objects;
    +  objects.reserve(components.size());
    +
    +  // 将每个组件转换为检测到的对象
    +  for (const auto & component : components) {
    +    if (component.size() > 3) {      // 过滤掉太小的组件（可能是噪声）
    +      auto object = componentToObject(component, map, next_object_id_++);
    +      objects.push_back(object);
    +    }
    +  }
    +
    +  return objects;
    +}
    +
    +std::vector<std::vector<std::pair<int, int>>> ObjectDetector::findConnectedComponents(
    +  const auto_msgs::msg::GridMap & map)
    +{
    +
    +  const int width = map.width;
    +  const int height = map.height;
    +  std::vector<bool> visited(width * height, false);
    +  std::vector<std::vector<std::pair<int, int>>> components;
    +
    +  // 四个方向的偏移（上、右、下、左）
    +  const std::vector<std::pair<int, int>> directions = {
    +    {0, -1}, {1, 0}, {0, 1}, {-1, 0}
    +  };
    +
    +  for (int y = 0; y < height; ++y) {
    +    for (int x = 0; x < width; ++x) {
    +      int index = y * width + x;
    +
    +      // 如果单元格被占用且尚未访问
    +      if (map.data[index] == 100 && !visited[index]) {
    +        std::vector<std::pair<int, int>> component;
    +        std::queue<std::pair<int, int>> queue;
    +
    +        // 标记为已访问
    +        visited[index] = true;
    +        queue.push({x, y});
    +        component.push_back({x, y});
    +
    +        while (!queue.empty()) {
    +          auto [cur_x, cur_y] = queue.front();
    +          queue.pop();
    +
    +          // 检查四个相邻的单元格
    +          for (const auto & [dx, dy] : directions) {
    +            int nx = cur_x + dx;
    +            int ny = cur_y + dy;
    +            int nindex = ny * width + nx;
    +
    +            // 检查边界
    +            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
    +              // 如果相邻单元格被占用且尚未访问
    +              if (map.data[nindex] == 100 && !visited[nindex]) {
    +                visited[nindex] = true;
    +                queue.push({nx, ny});
    +                component.push_back({nx, ny});
    +              }
    +            }
    +          }
    @@ -26,0 +84,3 @@
    +
    +        components.push_back(component);
    +      }
    @@ -28,56 +88,111 @@
    -    
    -    return objects;
    -}
    -
    -std::vector<std::vector<std::pair<int, int>>> ObjectDetector::findConnectedComponents(
    -    const auto_msgs::msg::GridMap& map) {
    -    
    -    const int width = map.width;
    -    const int height = map.height;
    -    std::vector<bool> visited(width * height, false);
    -    std::vector<std::vector<std::pair<int, int>>> components;
    -    
    -    // 四个方向的偏移（上、右、下、左）
    -    const std::vector<std::pair<int, int>> directions = {
    -        {0, -1}, {1, 0}, {0, 1}, {-1, 0}
    -    };
    -    
    -    for (int y = 0; y < height; ++y) {
    -        for (int x = 0; x < width; ++x) {
    -            int index = y * width + x;
    -            
    -            // 如果单元格被占用且尚未访问
    -            if (map.data[index] == 100 && !visited[index]) {
    -                std::vector<std::pair<int, int>> component;
    -                std::queue<std::pair<int, int>> queue;
    -                
    -                // 标记为已访问
    -                visited[index] = true;
    -                queue.push({x, y});
    -                component.push_back({x, y});
    -                
    -                while (!queue.empty()) {
    -                    auto [cur_x, cur_y] = queue.front();
    -                    queue.pop();
    -                    
    -                    // 检查四个相邻的单元格
    -                    for (const auto& [dx, dy] : directions) {
    -                        int nx = cur_x + dx;
    -                        int ny = cur_y + dy;
    -                        int nindex = ny * width + nx;
    -                        
    -                        // 检查边界
    -                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
    -                            // 如果相邻单元格被占用且尚未访问
    -                            if (map.data[nindex] == 100 && !visited[nindex]) {
    -                                visited[nindex] = true;
    -                                queue.push({nx, ny});
    -                                component.push_back({nx, ny});
    -                            }
    -                        }
    -                    }
    -                }
    -                
    -                components.push_back(component);
    -            }
    -        }
    +  }
    +
    +  return components;
    +}
    +
    +DetectedObject ObjectDetector::componentToObject(
    +  const std::vector<std::pair<int, int>> & component,
    +  const auto_msgs::msg::GridMap & map,
    +  int id)
    +{
    +
    +  // 计算组件的中心
    +  double sum_x = 0.0, sum_y = 0.0;
    +  for (const auto & [x, y] : component) {
    +    sum_x += x;
    +    sum_y += y;
    +  }
    +  double center_x = sum_x / component.size();
    +  double center_y = sum_y / component.size();
    +
    +  // 计算组件的最小/最大边界
    +  int min_x = component[0].first, max_x = component[0].first;
    +  int min_y = component[0].second, max_y = component[0].second;
    +
    +  for (const auto & [x, y] : component) {
    +    min_x = std::min(min_x, x);
    +    max_x = std::max(max_x, x);
    +    min_y = std::min(min_y, y);
    +    max_y = std::max(max_y, y);
    +  }
    +
    +  // 计算宽度和长度（以网格单元为单位）
    +  double width_cells = max_x - min_x + 1;
    +  double length_cells = max_y - min_y + 1;
    +
    +  // 转换为实际尺寸（米）
    +  double width = width_cells * map.resolution;
    +  double length = length_cells * map.resolution;
    +
    +  // 转换为世界坐标
    +  geometry_msgs::msg::Pose pose;
    +  pose.position.x = map.origin.position.x + (center_x + 0.5) * map.resolution;
    +  pose.position.y = map.origin.position.y + (center_y + 0.5) * map.resolution;
    +  pose.position.z = 0.5;    // 假设高度为1米，中心在0.5米
    +
    +  // 为对象分配一个随机方向（范围从0到2π）
    +  std::random_device rd;
    +  std::mt19937 gen(rd());
    +  std::uniform_real_distribution<> dis(0, 2 * M_PI);
    +  double yaw = dis(gen);
    +
    +  // 转换为四元数
    +  pose.orientation.w = cos(yaw / 2);
    +  pose.orientation.x = 0;
    +  pose.orientation.y = 0;
    +  pose.orientation.z = sin(yaw / 2);
    +
    +  // 创建并返回检测到的对象
    +  static const std::vector<std::string> classifications = {
    +    "vehicle", "pedestrian", "bicycle", "obstacle"
    +  };
    +
    +  std::uniform_int_distribution<> class_dis(0, classifications.size() - 1);
    +  std::string classification = classifications[class_dis(gen)];
    +
    +  std::uniform_real_distribution<> conf_dis(0.7, 1.0);
    +  double confidence = conf_dis(gen);
    +
    +  return DetectedObject(id, pose, width, length, 1.0, classification, confidence);
    +}
    +
    +visualization_msgs::msg::MarkerArray ObjectDetector::visualizeObjects(
    +  const std::vector<DetectedObject> & objects)
    +{
    +
    +  visualization_msgs::msg::MarkerArray marker_array;
    +
    +  for (const auto & obj : objects) {
    +    visualization_msgs::msg::Marker marker;
    +    marker.header.frame_id = "map";
    +    marker.header.stamp = rclcpp::Clock().now();
    +    marker.ns = "detected_objects";
    +    marker.id = obj.id;
    +    marker.type = visualization_msgs::msg::Marker::CUBE;
    +    marker.action = visualization_msgs::msg::Marker::ADD;
    +
    +    // 设置位置和方向
    +    marker.pose = obj.pose;
    +
    +    // 设置大小
    +    marker.scale.x = obj.length;
    +    marker.scale.y = obj.width;
    +    marker.scale.z = obj.height;
    +
    +    // 根据对象类型设置颜色
    +    if (obj.classification == "vehicle") {
    +      marker.color.r = 1.0;
    +      marker.color.g = 0.0;
    +      marker.color.b = 0.0;
    +    } else if (obj.classification == "pedestrian") {
    +      marker.color.r = 0.0;
    +      marker.color.g = 1.0;
    +      marker.color.b = 0.0;
    +    } else if (obj.classification == "bicycle") {
    +      marker.color.r = 0.0;
    +      marker.color.g = 0.0;
    +      marker.color.b = 1.0;
    +    } else {
    +      marker.color.r = 0.7;
    +      marker.color.g = 0.7;
    +      marker.color.b = 0.7;
    @@ -85,144 +200,35 @@
    -    
    -    return components;
    -}
    -
    -DetectedObject ObjectDetector::componentToObject(
    -    const std::vector<std::pair<int, int>>& component,
    -    const auto_msgs::msg::GridMap& map,
    -    int id) {
    -    
    -    // 计算组件的中心
    -    double sum_x = 0.0, sum_y = 0.0;
    -    for (const auto& [x, y] : component) {
    -        sum_x += x;
    -        sum_y += y;
    -    }
    -    double center_x = sum_x / component.size();
    -    double center_y = sum_y / component.size();
    -    
    -    // 计算组件的最小/最大边界
    -    int min_x = component[0].first, max_x = component[0].first;
    -    int min_y = component[0].second, max_y = component[0].second;
    -    
    -    for (const auto& [x, y] : component) {
    -        min_x = std::min(min_x, x);
    -        max_x = std::max(max_x, x);
    -        min_y = std::min(min_y, y);
    -        max_y = std::max(max_y, y);
    -    }
    -    
    -    // 计算宽度和长度（以网格单元为单位）
    -    double width_cells = max_x - min_x + 1;
    -    double length_cells = max_y - min_y + 1;
    -    
    -    // 转换为实际尺寸（米）
    -    double width = width_cells * map.resolution;
    -    double length = length_cells * map.resolution;
    -    
    -    // 转换为世界坐标
    -    geometry_msgs::msg::Pose pose;
    -    pose.position.x = map.origin.position.x + (center_x + 0.5) * map.resolution;
    -    pose.position.y = map.origin.position.y + (center_y + 0.5) * map.resolution;
    -    pose.position.z = 0.5;  // 假设高度为1米，中心在0.5米
    -    
    -    // 为对象分配一个随机方向（范围从0到2π）
    -    std::random_device rd;
    -    std::mt19937 gen(rd());
    -    std::uniform_real_distribution<> dis(0, 2 * M_PI);
    -    double yaw = dis(gen);
    -    
    -    // 转换为四元数
    -    pose.orientation.w = cos(yaw / 2);
    -    pose.orientation.x = 0;
    -    pose.orientation.y = 0;
    -    pose.orientation.z = sin(yaw / 2);
    -    
    -    // 创建并返回检测到的对象
    -    static const std::vector<std::string> classifications = {
    -        "vehicle", "pedestrian", "bicycle", "obstacle"
    -    };
    -    
    -    std::uniform_int_distribution<> class_dis(0, classifications.size() - 1);
    -    std::string classification = classifications[class_dis(gen)];
    -    
    -    std::uniform_real_distribution<> conf_dis(0.7, 1.0);
    -    double confidence = conf_dis(gen);
    -    
    -    return DetectedObject(id, pose, width, length, 1.0, classification, confidence);
    -}
    -
    -visualization_msgs::msg::MarkerArray ObjectDetector::visualizeObjects(
    -    const std::vector<DetectedObject>& objects) {
    -    
    -    visualization_msgs::msg::MarkerArray marker_array;
    -    
    -    for (const auto& obj : objects) {
    -        visualization_msgs::msg::Marker marker;
    -        marker.header.frame_id = "map";
    -        marker.header.stamp = rclcpp::Clock().now();
    -        marker.ns = "detected_objects";
    -        marker.id = obj.id;
    -        marker.type = visualization_msgs::msg::Marker::CUBE;
    -        marker.action = visualization_msgs::msg::Marker::ADD;
    -        
    -        // 设置位置和方向
    -        marker.pose = obj.pose;
    -        
    -        // 设置大小
    -        marker.scale.x = obj.length;
    -        marker.scale.y = obj.width;
    -        marker.scale.z = obj.height;
    -        
    -        // 根据对象类型设置颜色
    -        if (obj.classification == "vehicle") {
    -            marker.color.r = 1.0;
    -            marker.color.g = 0.0;
    -            marker.color.b = 0.0;
    -        } else if (obj.classification == "pedestrian") {
    -            marker.color.r = 0.0;
    -            marker.color.g = 1.0;
    -            marker.color.b = 0.0;
    -        } else if (obj.classification == "bicycle") {
    -            marker.color.r = 0.0;
    -            marker.color.g = 0.0;
    -            marker.color.b = 1.0;
    -        } else {
    -            marker.color.r = 0.7;
    -            marker.color.g = 0.7;
    -            marker.color.b = 0.7;
    -        }
    -        marker.color.a = 0.8 * obj.confidence;  // 设置透明度
    -        
    -        // 设置生命周期
    -        marker.lifetime = rclcpp::Duration::from_seconds(1.0);
    -        
    -        marker_array.markers.push_back(marker);
    -        
    -        // 添加文本标签
    -        visualization_msgs::msg::Marker text_marker;
    -        text_marker.header = marker.header;
    -        text_marker.ns = "object_labels";
    -        text_marker.id = obj.id;
    -        text_marker.type = visualization_msgs::msg::Marker::TEXT_VIEW_FACING;
    -        text_marker.action = visualization_msgs::msg::Marker::ADD;
    -        
    -        text_marker.pose = obj.pose;
    -        text_marker.pose.position.z += obj.height / 2 + 0.5;  // 将文本置于对象上方
    -        
    -        text_marker.scale.z = 0.5;  // 文本高度
    -        text_marker.color.r = 1.0;
    -        text_marker.color.g = 1.0;
    -        text_marker.color.b = 1.0;
    -        text_marker.color.a = 1.0;
    -        
    -        // 设置文本内容
    -        std::ostringstream ss;
    -        ss << obj.classification << " (" << std::fixed << std::setprecision(2) << obj.confidence << ")";
    -        text_marker.text = ss.str();
    -        
    -        text_marker.lifetime = rclcpp::Duration::from_seconds(1.0);
    -        
    -        marker_array.markers.push_back(text_marker);
    -    }
    -    
    -    return marker_array;
    +    marker.color.a = 0.8 * obj.confidence;      // 设置透明度
    +
    +    // 设置生命周期
    +    marker.lifetime = rclcpp::Duration::from_seconds(1.0);
    +
    +    marker_array.markers.push_back(marker);
    +
    +    // 添加文本标签
    +    visualization_msgs::msg::Marker text_marker;
    +    text_marker.header = marker.header;
    +    text_marker.ns = "object_labels";
    +    text_marker.id = obj.id;
    +    text_marker.type = visualization_msgs::msg::Marker::TEXT_VIEW_FACING;
    +    text_marker.action = visualization_msgs::msg::Marker::ADD;
    +
    +    text_marker.pose = obj.pose;
    +    text_marker.pose.position.z += obj.height / 2 + 0.5;      // 将文本置于对象上方
    +
    +    text_marker.scale.z = 0.5;      // 文本高度
    +    text_marker.color.r = 1.0;
    +    text_marker.color.g = 1.0;
    +    text_marker.color.b = 1.0;
    +    text_marker.color.a = 1.0;
    +
    +    // 设置文本内容
    +    std::ostringstream ss;
    +    ss << obj.classification << " (" << std::fixed << std::setprecision(2) << obj.confidence << ")";
    +    text_marker.text = ss.str();
    +
    +    text_marker.lifetime = rclcpp::Duration::from_seconds(1.0);
    +
    +    marker_array.markers.push_back(text_marker);
    +  }
    +
    +  return marker_array;
    
    Code style divergence in file 'src/perception_node.cpp':
    
    --- src/perception_node.cpp
    +++ src/perception_node.cpp.uncrustify
    @@ -13 +13,2 @@
    -namespace auto_perception {
    +namespace auto_perception
    +{
    @@ -15 +16,2 @@
    -class PerceptionNode : public rclcpp::Node {
    +class PerceptionNode : public rclcpp::Node
    +{
    @@ -17,17 +19,33 @@
    -    PerceptionNode() : Node("perception_node") {
    -        // 创建对象检测器
    -        detector_ = std::make_unique<ObjectDetector>();
    -        
    -        // 创建订阅者
    -        map_sub_ = this->create_subscription<auto_msgs::msg::GridMap>(
    -            "grid_map", 10, std::bind(&PerceptionNode::mapCallback, this, _1));
    -        
    -        // 创建发布者
    -        objects_vis_pub_ = this->create_publisher<visualization_msgs::msg::MarkerArray>(
    -            "detected_objects_markers", 10);
    -        
    -        // 创建定时器用于处理感知任务
    -        perception_timer_ = this->create_wall_timer(
    -            100ms, std::bind(&PerceptionNode::perceptionUpdate, this));
    -        
    -        RCLCPP_INFO(this->get_logger(), "感知节点已启动");
    +  PerceptionNode()
    +  : Node("perception_node")
    +  {
    +    // 创建对象检测器
    +    detector_ = std::make_unique<ObjectDetector>();
    +
    +    // 创建订阅者
    +    map_sub_ = this->create_subscription<auto_msgs::msg::GridMap>(
    +      "grid_map", 10, std::bind(&PerceptionNode::mapCallback, this, _1));
    +
    +    // 创建发布者
    +    objects_vis_pub_ = this->create_publisher<visualization_msgs::msg::MarkerArray>(
    +      "detected_objects_markers", 10);
    +
    +    // 创建定时器用于处理感知任务
    +    perception_timer_ = this->create_wall_timer(
    +      100ms, std::bind(&PerceptionNode::perceptionUpdate, this));
    +
    +    RCLCPP_INFO(this->get_logger(), "感知节点已启动");
    +  }
    +
    +private:
    +  void mapCallback(const auto_msgs::msg::GridMap::SharedPtr msg)
    +  {
    +    RCLCPP_INFO(this->get_logger(), "收到地图，尺寸: %dx%d", msg->width, msg->height);
    +    current_map_ = *msg;
    +    have_map_ = true;
    +  }
    +
    +  void perceptionUpdate()
    +  {
    +    if (!have_map_) {
    +      return;
    @@ -36,5 +54,12 @@
    -private:
    -    void mapCallback(const auto_msgs::msg::GridMap::SharedPtr msg) {
    -        RCLCPP_INFO(this->get_logger(), "收到地图，尺寸: %dx%d", msg->width, msg->height);
    -        current_map_ = *msg;
    -        have_map_ = true;
    +    // 从地图中检测对象
    +    auto detected_objects = detector_->detectObjects(current_map_);
    +
    +    if (!detected_objects.empty()) {
    +      RCLCPP_INFO(this->get_logger(), "检测到 %zu 个对象", detected_objects.size());
    +
    +      // 可视化检测到的对象
    +      auto markers = detector_->visualizeObjects(detected_objects);
    +      objects_vis_pub_->publish(markers);
    +
    +      // 存储检测到的对象
    +      current_objects_ = detected_objects;
    @@ -42,29 +67,10 @@
    -    
    -    void perceptionUpdate() {
    -        if (!have_map_) {
    -            return;
    -        }
    -        
    -        // 从地图中检测对象
    -        auto detected_objects = detector_->detectObjects(current_map_);
    -        
    -        if (!detected_objects.empty()) {
    -            RCLCPP_INFO(this->get_logger(), "检测到 %zu 个对象", detected_objects.size());
    -            
    -            // 可视化检测到的对象
    -            auto markers = detector_->visualizeObjects(detected_objects);
    -            objects_vis_pub_->publish(markers);
    -            
    -            // 存储检测到的对象
    -            current_objects_ = detected_objects;
    -        }
    -    }
    -    
    -    std::unique_ptr<ObjectDetector> detector_;
    -    auto_msgs::msg::GridMap current_map_;
    -    std::vector<DetectedObject> current_objects_;
    -    bool have_map_ = false;
    -    
    -    rclcpp::Subscription<auto_msgs::msg::GridMap>::SharedPtr map_sub_;
    -    rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr objects_vis_pub_;
    -    rclcpp::TimerBase::SharedPtr perception_timer_;
    +  }
    +
    +  std::unique_ptr<ObjectDetector> detector_;
    +  auto_msgs::msg::GridMap current_map_;
    +  std::vector<DetectedObject> current_objects_;
    +  bool have_map_ = false;
    +
    +  rclcpp::Subscription<auto_msgs::msg::GridMap>::SharedPtr map_sub_;
    +  rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr objects_vis_pub_;
    +  rclcpp::TimerBase::SharedPtr perception_timer_;
    @@ -75,6 +81,7 @@
    -int main(int argc, char * argv[]) {
    -    rclcpp::init(argc, argv);
    -    auto node = std::make_shared<auto_perception::PerceptionNode>();
    -    rclcpp::spin(node);
    -    rclcpp::shutdown();
    -    return 0;
    +int main(int argc, char * argv[])
    +{
    +  rclcpp::init(argc, argv);
    +  auto node = std::make_shared<auto_perception::PerceptionNode>();
    +  rclcpp::spin(node);
    +  rclcpp::shutdown();
    +  return 0;
    
    3 files with code style divergence
    -- run_test.py: return code 1
    -- run_test.py: verify result file '/home/onion/samples/autonomous_driving_ws/build/auto_perception/test_results/auto_perception/uncrustify.xunit.xml'
  >>>
build/auto_perception/test_results/auto_perception/lint_cmake.xunit.xml: 1 test, 0 errors, 1 failure, 0 skipped
- auto_perception.lint_cmake whitespace/eol (CMakeLists.txt:64)
  <<< failure message
    Line ends in whitespace
  >>>
build/auto_perception/test_results/auto_perception/uncrustify.xunit.xml: 3 tests, 0 errors, 3 failures, 0 skipped
- auto_perception.uncrustify include/auto_perception/object_detector.hpp
  <<< failure message
    Diff with 89 lines
  >>>
- auto_perception.uncrustify src/object_detector.cpp
  <<< failure message
    Diff with 444 lines
  >>>
- auto_perception.uncrustify src/perception_node.cpp
  <<< failure message
    Diff with 133 lines
  >>>
build/auto_simulation/Testing/20250526-0636/Test.xml: 4 tests, 0 errors, 2 failures, 0 skipped
- lint_cmake
  <<< failure message
    -- run_test.py: invoking following command in '/home/onion/samples/autonomous_driving_ws/src/auto_simulation':
     - /opt/ros/humble/bin/ament_lint_cmake --xunit-file /home/onion/samples/autonomous_driving_ws/build/auto_simulation/test_results/auto_simulation/lint_cmake.xunit.xml
    CMakeLists.txt:34: Line ends in whitespace [whitespace/eol]
    
    
    1 errors
    -- run_test.py: return code 1
    -- run_test.py: verify result file '/home/onion/samples/autonomous_driving_ws/build/auto_simulation/test_results/auto_simulation/lint_cmake.xunit.xml'
  >>>
- uncrustify
  <<< failure message
    -- run_test.py: invoking following command in '/home/onion/samples/autonomous_driving_ws/src/auto_simulation':
     - /opt/ros/humble/bin/ament_uncrustify --xunit-file /home/onion/samples/autonomous_driving_ws/build/auto_simulation/test_results/auto_simulation/uncrustify.xunit.xml
    Code style divergence in file 'include/auto_simulation/mqtt_bridge.hpp':
    
    --- include/auto_simulation/mqtt_bridge.hpp
    +++ include/auto_simulation/mqtt_bridge.hpp.uncrustify
    @@ -12 +12,2 @@
    -namespace auto_simulation {
    +namespace auto_simulation
    +{
    @@ -15 +16,2 @@
    -using MqttMessageCallback = std::function<void(const std::string& topic, const std::string& payload)>;
    +using MqttMessageCallback = std::function<void (const std::string & topic,
    +    const std::string & payload)>;
    @@ -17 +19,2 @@
    -class MqttBridge {
    +class MqttBridge
    +{
    @@ -19,2 +22,4 @@
    -    MqttBridge(const std::string& client_id, const std::string& host = "localhost", int port = 1883);
    -    virtual ~MqttBridge();
    +  MqttBridge(
    +    const std::string & client_id, const std::string & host = "localhost",
    +    int port = 1883);
    +  virtual ~MqttBridge();
    @@ -22,29 +27,29 @@
    -    // 连接到MQTT代理
    -    bool connect();
    -    
    -    // 断开与MQTT代理的连接
    -    void disconnect();
    -    
    -    // 发布消息
    -    bool publish(const std::string& topic, const std::string& payload, int qos = 0);
    -    
    -    // 订阅主题
    -    bool subscribe(const std::string& topic, int qos = 0);
    -    
    -    // 取消订阅主题
    -    bool unsubscribe(const std::string& topic);
    -    
    -    // 设置消息回调
    -    void setMessageCallback(MqttMessageCallback callback);
    -    
    -    // 处理MQTT事件
    -    void spin(int timeout_ms = 100);
    -    
    -    // 发布自动驾驶系统相关消息
    -    bool publishGridMap(const auto_msgs::msg::GridMap& map);
    -    bool publishVehiclePose(const geometry_msgs::msg::PoseStamped& pose);
    -    bool publishPlanningPath(const auto_msgs::msg::PlanningPath& path);
    -    
    -    // 从JSON解析消息
    -    auto_msgs::msg::GridMap parseGridMap(const std::string& json);
    -    geometry_msgs::msg::PoseStamped parsePoseStamped(const std::string& json);
    +  // 连接到MQTT代理
    +  bool connect();
    +
    +  // 断开与MQTT代理的连接
    +  void disconnect();
    +
    +  // 发布消息
    +  bool publish(const std::string & topic, const std::string & payload, int qos = 0);
    +
    +  // 订阅主题
    +  bool subscribe(const std::string & topic, int qos = 0);
    +
    +  // 取消订阅主题
    +  bool unsubscribe(const std::string & topic);
    +
    +  // 设置消息回调
    +  void setMessageCallback(MqttMessageCallback callback);
    +
    +  // 处理MQTT事件
    +  void spin(int timeout_ms = 100);
    +
    +  // 发布自动驾驶系统相关消息
    +  bool publishGridMap(const auto_msgs::msg::GridMap & map);
    +  bool publishVehiclePose(const geometry_msgs::msg::PoseStamped & pose);
    +  bool publishPlanningPath(const auto_msgs::msg::PlanningPath & path);
    +
    +  // 从JSON解析消息
    +  auto_msgs::msg::GridMap parseGridMap(const std::string & json);
    +  geometry_msgs::msg::PoseStamped parsePoseStamped(const std::string & json);
    @@ -53,18 +58,20 @@
    -    // MQTT回调函数
    -    static void onConnect(struct mosquitto* mosq, void* obj, int rc);
    -    static void onDisconnect(struct mosquitto* mosq, void* obj, int reason);
    -    static void onMessage(struct mosquitto* mosq, void* obj, const struct mosquitto_message* message);
    -    
    -    // MQTT客户端
    -    struct mosquitto* mosq_;
    -    
    -    // MQTT代理信息
    -    std::string client_id_;
    -    std::string host_;
    -    int port_;
    -    
    -    // 消息回调
    -    MqttMessageCallback message_callback_;
    -    
    -    // 连接状态
    -    bool connected_;
    +  // MQTT回调函数
    +  static void onConnect(struct mosquitto * mosq, void * obj, int rc);
    +  static void onDisconnect(struct mosquitto * mosq, void * obj, int reason);
    +  static void onMessage(
    +    struct mosquitto * mosq, void * obj,
    +    const struct mosquitto_message * message);
    +
    +  // MQTT客户端
    +  struct mosquitto * mosq_;
    +
    +  // MQTT代理信息
    +  std::string client_id_;
    +  std::string host_;
    +  int port_;
    +
    +  // 消息回调
    +  MqttMessageCallback message_callback_;
    +
    +  // 连接状态
    +  bool connected_;
    
    Code style divergence in file 'src/mqtt_bridge.cpp':
    
    --- src/mqtt_bridge.cpp
    +++ src/mqtt_bridge.cpp.uncrustify
    @@ -7,12 +7,159 @@
    -namespace auto_simulation {
    -
    -MqttBridge::MqttBridge(const std::string& client_id, const std::string& host, int port)
    -    : client_id_(client_id), host_(host), port_(port), connected_(false) {
    -    
    -    // 初始化MQTT库
    -    mosquitto_lib_init();
    -    
    -    // 创建MQTT客户端实例
    -    mosq_ = mosquitto_new(client_id_.c_str(), true, this);
    -    if (!mosq_) {
    -        throw std::runtime_error("无法创建MQTT客户端实例");
    +namespace auto_simulation
    +{
    +
    +MqttBridge::MqttBridge(const std::string & client_id, const std::string & host, int port)
    +: client_id_(client_id), host_(host), port_(port), connected_(false)
    +{
    +
    +  // 初始化MQTT库
    +  mosquitto_lib_init();
    +
    +  // 创建MQTT客户端实例
    +  mosq_ = mosquitto_new(client_id_.c_str(), true, this);
    +  if (!mosq_) {
    +    throw std::runtime_error("无法创建MQTT客户端实例");
    +  }
    +
    +  // 设置回调函数
    +  mosquitto_connect_callback_set(mosq_, onConnect);
    +  mosquitto_disconnect_callback_set(mosq_, onDisconnect);
    +  mosquitto_message_callback_set(mosq_, onMessage);
    +}
    +
    +MqttBridge::~MqttBridge()
    +{
    +  if (connected_) {
    +    disconnect();
    +  }
    +
    +  if (mosq_) {
    +    mosquitto_destroy(mosq_);
    +    mosq_ = nullptr;
    +  }
    +
    +  mosquitto_lib_cleanup();
    +}
    +
    +bool MqttBridge::connect()
    +{
    +  int rc = mosquitto_connect(mosq_, host_.c_str(), port_, 60);
    +  if (rc != MOSQ_ERR_SUCCESS) {
    +    RCLCPP_ERROR(
    +      rclcpp::get_logger("mqtt_bridge"),
    +      "无法连接到MQTT代理 %s:%d: %s",
    +      host_.c_str(), port_, mosquitto_strerror(rc));
    +    return false;
    +  }
    +
    +  // 启动网络循环
    +  rc = mosquitto_loop_start(mosq_);
    +  if (rc != MOSQ_ERR_SUCCESS) {
    +    RCLCPP_ERROR(
    +      rclcpp::get_logger("mqtt_bridge"),
    +      "无法启动MQTT网络循环: %s", mosquitto_strerror(rc));
    +    return false;
    +  }
    +
    +  return true;
    +}
    +
    +void MqttBridge::disconnect()
    +{
    +  if (mosq_ && connected_) {
    +    mosquitto_disconnect(mosq_);
    +    mosquitto_loop_stop(mosq_, true);
    +    connected_ = false;
    +  }
    +}
    +
    +bool MqttBridge::publish(const std::string & topic, const std::string & payload, int qos)
    +{
    +  if (!mosq_ || !connected_) {
    +    RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), "MQTT客户端未连接");
    +    return false;
    +  }
    +
    +  int rc = mosquitto_publish(
    +    mosq_, nullptr, topic.c_str(),
    +    static_cast<int>(payload.size()), payload.c_str(), qos, false);
    +
    +  if (rc != MOSQ_ERR_SUCCESS) {
    +    RCLCPP_ERROR(
    +      rclcpp::get_logger("mqtt_bridge"),
    +      "发布消息失败: %s", mosquitto_strerror(rc));
    +    return false;
    +  }
    +
    +  return true;
    +}
    +
    +bool MqttBridge::subscribe(const std::string & topic, int qos)
    +{
    +  if (!mosq_ || !connected_) {
    +    RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), "MQTT客户端未连接");
    +    return false;
    +  }
    +
    +  int rc = mosquitto_subscribe(mosq_, nullptr, topic.c_str(), qos);
    +  if (rc != MOSQ_ERR_SUCCESS) {
    +    RCLCPP_ERROR(
    +      rclcpp::get_logger("mqtt_bridge"),
    +      "订阅主题失败: %s", mosquitto_strerror(rc));
    +    return false;
    +  }
    +
    +  return true;
    +}
    +
    +bool MqttBridge::unsubscribe(const std::string & topic)
    +{
    +  if (!mosq_ || !connected_) {
    +    RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), "MQTT客户端未连接");
    +    return false;
    +  }
    +
    +  int rc = mosquitto_unsubscribe(mosq_, nullptr, topic.c_str());
    +  if (rc != MOSQ_ERR_SUCCESS) {
    +    RCLCPP_ERROR(
    +      rclcpp::get_logger("mqtt_bridge"),
    +      "取消订阅主题失败: %s", mosquitto_strerror(rc));
    +    return false;
    +  }
    +
    +  return true;
    +}
    +
    +void MqttBridge::setMessageCallback(MqttMessageCallback callback)
    +{
    +  message_callback_ = callback;
    +}
    +
    +void MqttBridge::spin(int timeout_ms)
    +{
    +  if (mosq_ && connected_) {
    +    mosquitto_loop(mosq_, timeout_ms, 1);
    +  }
    +}
    +
    +bool MqttBridge::publishGridMap(const auto_msgs::msg::GridMap & map)
    +{
    +  try {
    +    json j;
    +    j["header"]["frame_id"] = map.header.frame_id;
    +    j["header"]["stamp"]["sec"] = map.header.stamp.sec;
    +    j["header"]["stamp"]["nanosec"] = map.header.stamp.nanosec;
    +    j["width"] = map.width;
    +    j["height"] = map.height;
    +    j["resolution"] = map.resolution;
    +    j["origin"]["position"]["x"] = map.origin.position.x;
    +    j["origin"]["position"]["y"] = map.origin.position.y;
    +    j["origin"]["position"]["z"] = map.origin.position.z;
    +    j["origin"]["orientation"]["x"] = map.origin.orientation.x;
    +    j["origin"]["orientation"]["y"] = map.origin.orientation.y;
    +    j["origin"]["orientation"]["z"] = map.origin.orientation.z;
    +    j["origin"]["orientation"]["w"] = map.origin.orientation.w;
    +
    +    // 将地图数据转换为base64编码以减小大小
    +    std::vector<uint8_t> data;
    +    for (auto value : map.data) {
    +      data.push_back(static_cast<uint8_t>(value));
    @@ -20,10 +167,60 @@
    -    
    -    // 设置回调函数
    -    mosquitto_connect_callback_set(mosq_, onConnect);
    -    mosquitto_disconnect_callback_set(mosq_, onDisconnect);
    -    mosquitto_message_callback_set(mosq_, onMessage);
    -}
    -
    -MqttBridge::~MqttBridge() {
    -    if (connected_) {
    -        disconnect();
    +    j["data"] = data;
    +
    +    return publish("auto_driving/grid_map", j.dump());
    +  } catch (const std::exception & e) {
    +    RCLCPP_ERROR(
    +      rclcpp::get_logger("mqtt_bridge"),
    +      "发布网格地图失败: %s", e.what());
    +    return false;
    +  }
    +}
    +
    +bool MqttBridge::publishVehiclePose(const geometry_msgs::msg::PoseStamped & pose)
    +{
    +  try {
    +    json j;
    +    j["header"]["frame_id"] = pose.header.frame_id;
    +    j["header"]["stamp"]["sec"] = pose.header.stamp.sec;
    +    j["header"]["stamp"]["nanosec"] = pose.header.stamp.nanosec;
    +    j["pose"]["position"]["x"] = pose.pose.position.x;
    +    j["pose"]["position"]["y"] = pose.pose.position.y;
    +    j["pose"]["position"]["z"] = pose.pose.position.z;
    +    j["pose"]["orientation"]["x"] = pose.pose.orientation.x;
    +    j["pose"]["orientation"]["y"] = pose.pose.orientation.y;
    +    j["pose"]["orientation"]["z"] = pose.pose.orientation.z;
    +    j["pose"]["orientation"]["w"] = pose.pose.orientation.w;
    +
    +    return publish("auto_driving/vehicle_pose", j.dump());
    +  } catch (const std::exception & e) {
    +    RCLCPP_ERROR(
    +      rclcpp::get_logger("mqtt_bridge"),
    +      "发布车辆位姿失败: %s", e.what());
    +    return false;
    +  }
    +}
    +
    +bool MqttBridge::publishPlanningPath(const auto_msgs::msg::PlanningPath & path)
    +{
    +  try {
    +    json j;
    +    j["header"]["frame_id"] = path.header.frame_id;
    +    j["header"]["stamp"]["sec"] = path.header.stamp.sec;
    +    j["header"]["stamp"]["nanosec"] = path.header.stamp.nanosec;
    +    j["planner_type"] = path.planner_type;
    +    j["total_distance"] = path.total_distance;
    +    j["planning_time"] = path.planning_time;
    +
    +    json points = json::array();
    +    for (const auto & point : path.points) {
    +      json p;
    +      p["pose"]["position"]["x"] = point.pose.position.x;
    +      p["pose"]["position"]["y"] = point.pose.position.y;
    +      p["pose"]["position"]["z"] = point.pose.position.z;
    +      p["pose"]["orientation"]["x"] = point.pose.orientation.x;
    +      p["pose"]["orientation"]["y"] = point.pose.orientation.y;
    +      p["pose"]["orientation"]["z"] = point.pose.orientation.z;
    +      p["pose"]["orientation"]["w"] = point.pose.orientation.w;
    +      p["steering_angle"] = point.steering_angle;
    +      p["velocity"] = point.velocity;
    +      p["curvature"] = point.curvature;
    +      points.push_back(p);
    @@ -31,4 +228,37 @@
    -    
    -    if (mosq_) {
    -        mosquitto_destroy(mosq_);
    -        mosq_ = nullptr;
    +    j["points"] = points;
    +
    +    return publish("auto_driving/planning_path", j.dump());
    +  } catch (const std::exception & e) {
    +    RCLCPP_ERROR(
    +      rclcpp::get_logger("mqtt_bridge"),
    +      "发布规划路径失败: %s", e.what());
    +    return false;
    +  }
    +}
    +
    +auto_msgs::msg::GridMap MqttBridge::parseGridMap(const std::string & json_str)
    +{
    +  auto_msgs::msg::GridMap map;
    +
    +  try {
    +    json j = json::parse(json_str);
    +
    +    map.header.frame_id = j["header"]["frame_id"];
    +    map.header.stamp.sec = j["header"]["stamp"]["sec"];
    +    map.header.stamp.nanosec = j["header"]["stamp"]["nanosec"];
    +    map.width = j["width"];
    +    map.height = j["height"];
    +    map.resolution = j["resolution"];
    +    map.origin.position.x = j["origin"]["position"]["x"];
    +    map.origin.position.y = j["origin"]["position"]["y"];
    +    map.origin.position.z = j["origin"]["position"]["z"];
    +    map.origin.orientation.x = j["origin"]["orientation"]["x"];
    +    map.origin.orientation.y = j["origin"]["orientation"]["y"];
    +    map.origin.orientation.z = j["origin"]["orientation"]["z"];
    +    map.origin.orientation.w = j["origin"]["orientation"]["w"];
    +
    +    // 解析地图数据
    +    auto data = j["data"].get<std::vector<uint8_t>>();
    +    map.data.resize(data.size());
    +    for (size_t i = 0; i < data.size(); ++i) {
    +      map.data[i] = static_cast<int8_t>(data[i]);
    @@ -36,11 +266,73 @@
    -    
    -    mosquitto_lib_cleanup();
    -}
    -
    -bool MqttBridge::connect() {
    -    int rc = mosquitto_connect(mosq_, host_.c_str(), port_, 60);
    -    if (rc != MOSQ_ERR_SUCCESS) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), 
    -            "无法连接到MQTT代理 %s:%d: %s", 
    -            host_.c_str(), port_, mosquitto_strerror(rc));
    -        return false;
    +  } catch (const std::exception & e) {
    +    RCLCPP_ERROR(
    +      rclcpp::get_logger("mqtt_bridge"),
    +      "解析网格地图失败: %s", e.what());
    +  }
    +
    +  return map;
    +}
    +
    +geometry_msgs::msg::PoseStamped MqttBridge::parsePoseStamped(const std::string & json_str)
    +{
    +  geometry_msgs::msg::PoseStamped pose;
    +
    +  try {
    +    json j = json::parse(json_str);
    +
    +    pose.header.frame_id = j["header"]["frame_id"];
    +    pose.header.stamp.sec = j["header"]["stamp"]["sec"];
    +    pose.header.stamp.nanosec = j["header"]["stamp"]["nanosec"];
    +    pose.pose.position.x = j["pose"]["position"]["x"];
    +    pose.pose.position.y = j["pose"]["position"]["y"];
    +    pose.pose.position.z = j["pose"]["position"]["z"];
    +    pose.pose.orientation.x = j["pose"]["orientation"]["x"];
    +    pose.pose.orientation.y = j["pose"]["orientation"]["y"];
    +    pose.pose.orientation.z = j["pose"]["orientation"]["z"];
    +    pose.pose.orientation.w = j["pose"]["orientation"]["w"];
    +  } catch (const std::exception & e) {
    +    RCLCPP_ERROR(
    +      rclcpp::get_logger("mqtt_bridge"),
    +      "解析位姿失败: %s", e.what());
    +  }
    +
    +  return pose;
    +}
    +
    +// 静态回调函数
    +void MqttBridge::onConnect(struct mosquitto * mosq, void * obj, int rc)
    +{
    +  auto * bridge = static_cast<MqttBridge *>(obj);
    +  if (rc == 0) {
    +    bridge->connected_ = true;
    +    RCLCPP_INFO(
    +      rclcpp::get_logger("mqtt_bridge"),
    +      "已连接到MQTT代理 %s:%d", bridge->host_.c_str(), bridge->port_);
    +  } else {
    +    bridge->connected_ = false;
    +    RCLCPP_ERROR(
    +      rclcpp::get_logger("mqtt_bridge"),
    +      "连接到MQTT代理失败: %s", mosquitto_connack_string(rc));
    +  }
    +}
    +
    +void MqttBridge::onDisconnect(struct mosquitto * mosq, void * obj, int reason)
    +{
    +  auto * bridge = static_cast<MqttBridge *>(obj);
    +  bridge->connected_ = false;
    +  RCLCPP_INFO(
    +    rclcpp::get_logger("mqtt_bridge"),
    +    "与MQTT代理断开连接: %s", mosquitto_strerror(reason));
    +}
    +
    +void MqttBridge::onMessage(
    +  struct mosquitto * mosq, void * obj,
    +  const struct mosquitto_message * message)
    +{
    +  auto * bridge = static_cast<MqttBridge *>(obj);
    +
    +  if (bridge->message_callback_) {
    +    std::string topic = message->topic;
    +    std::string payload;
    +
    +    if (message->payload) {
    +      payload = std::string(static_cast<const char *>(message->payload), message->payloadlen);
    @@ -48,262 +340,3 @@
    -    
    -    // 启动网络循环
    -    rc = mosquitto_loop_start(mosq_);
    -    if (rc != MOSQ_ERR_SUCCESS) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), 
    -            "无法启动MQTT网络循环: %s", mosquitto_strerror(rc));
    -        return false;
    -    }
    -    
    -    return true;
    -}
    -
    -void MqttBridge::disconnect() {
    -    if (mosq_ && connected_) {
    -        mosquitto_disconnect(mosq_);
    -        mosquitto_loop_stop(mosq_, true);
    -        connected_ = false;
    -    }
    -}
    -
    -bool MqttBridge::publish(const std::string& topic, const std::string& payload, int qos) {
    -    if (!mosq_ || !connected_) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), "MQTT客户端未连接");
    -        return false;
    -    }
    -    
    -    int rc = mosquitto_publish(mosq_, nullptr, topic.c_str(), 
    -        static_cast<int>(payload.size()), payload.c_str(), qos, false);
    -        
    -    if (rc != MOSQ_ERR_SUCCESS) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), 
    -            "发布消息失败: %s", mosquitto_strerror(rc));
    -        return false;
    -    }
    -    
    -    return true;
    -}
    -
    -bool MqttBridge::subscribe(const std::string& topic, int qos) {
    -    if (!mosq_ || !connected_) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), "MQTT客户端未连接");
    -        return false;
    -    }
    -    
    -    int rc = mosquitto_subscribe(mosq_, nullptr, topic.c_str(), qos);
    -    if (rc != MOSQ_ERR_SUCCESS) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), 
    -            "订阅主题失败: %s", mosquitto_strerror(rc));
    -        return false;
    -    }
    -    
    -    return true;
    -}
    -
    -bool MqttBridge::unsubscribe(const std::string& topic) {
    -    if (!mosq_ || !connected_) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), "MQTT客户端未连接");
    -        return false;
    -    }
    -    
    -    int rc = mosquitto_unsubscribe(mosq_, nullptr, topic.c_str());
    -    if (rc != MOSQ_ERR_SUCCESS) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), 
    -            "取消订阅主题失败: %s", mosquitto_strerror(rc));
    -        return false;
    -    }
    -    
    -    return true;
    -}
    -
    -void MqttBridge::setMessageCallback(MqttMessageCallback callback) {
    -    message_callback_ = callback;
    -}
    -
    -void MqttBridge::spin(int timeout_ms) {
    -    if (mosq_ && connected_) {
    -        mosquitto_loop(mosq_, timeout_ms, 1);
    -    }
    -}
    -
    -bool MqttBridge::publishGridMap(const auto_msgs::msg::GridMap& map) {
    -    try {
    -        json j;
    -        j["header"]["frame_id"] = map.header.frame_id;
    -        j["header"]["stamp"]["sec"] = map.header.stamp.sec;
    -        j["header"]["stamp"]["nanosec"] = map.header.stamp.nanosec;
    -        j["width"] = map.width;
    -        j["height"] = map.height;
    -        j["resolution"] = map.resolution;
    -        j["origin"]["position"]["x"] = map.origin.position.x;
    -        j["origin"]["position"]["y"] = map.origin.position.y;
    -        j["origin"]["position"]["z"] = map.origin.position.z;
    -        j["origin"]["orientation"]["x"] = map.origin.orientation.x;
    -        j["origin"]["orientation"]["y"] = map.origin.orientation.y;
    -        j["origin"]["orientation"]["z"] = map.origin.orientation.z;
    -        j["origin"]["orientation"]["w"] = map.origin.orientation.w;
    -        
    -        // 将地图数据转换为base64编码以减小大小
    -        std::vector<uint8_t> data;
    -        for (auto value : map.data) {
    -            data.push_back(static_cast<uint8_t>(value));
    -        }
    -        j["data"] = data;
    -        
    -        return publish("auto_driving/grid_map", j.dump());
    -    } catch (const std::exception& e) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), 
    -            "发布网格地图失败: %s", e.what());
    -        return false;
    -    }
    -}
    -
    -bool MqttBridge::publishVehiclePose(const geometry_msgs::msg::PoseStamped& pose) {
    -    try {
    -        json j;
    -        j["header"]["frame_id"] = pose.header.frame_id;
    -        j["header"]["stamp"]["sec"] = pose.header.stamp.sec;
    -        j["header"]["stamp"]["nanosec"] = pose.header.stamp.nanosec;
    -        j["pose"]["position"]["x"] = pose.pose.position.x;
    -        j["pose"]["position"]["y"] = pose.pose.position.y;
    -        j["pose"]["position"]["z"] = pose.pose.position.z;
    -        j["pose"]["orientation"]["x"] = pose.pose.orientation.x;
    -        j["pose"]["orientation"]["y"] = pose.pose.orientation.y;
    -        j["pose"]["orientation"]["z"] = pose.pose.orientation.z;
    -        j["pose"]["orientation"]["w"] = pose.pose.orientation.w;
    -        
    -        return publish("auto_driving/vehicle_pose", j.dump());
    -    } catch (const std::exception& e) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), 
    -            "发布车辆位姿失败: %s", e.what());
    -        return false;
    -    }
    -}
    -
    -bool MqttBridge::publishPlanningPath(const auto_msgs::msg::PlanningPath& path) {
    -    try {
    -        json j;
    -        j["header"]["frame_id"] = path.header.frame_id;
    -        j["header"]["stamp"]["sec"] = path.header.stamp.sec;
    -        j["header"]["stamp"]["nanosec"] = path.header.stamp.nanosec;
    -        j["planner_type"] = path.planner_type;
    -        j["total_distance"] = path.total_distance;
    -        j["planning_time"] = path.planning_time;
    -        
    -        json points = json::array();
    -        for (const auto& point : path.points) {
    -            json p;
    -            p["pose"]["position"]["x"] = point.pose.position.x;
    -            p["pose"]["position"]["y"] = point.pose.position.y;
    -            p["pose"]["position"]["z"] = point.pose.position.z;
    -            p["pose"]["orientation"]["x"] = point.pose.orientation.x;
    -            p["pose"]["orientation"]["y"] = point.pose.orientation.y;
    -            p["pose"]["orientation"]["z"] = point.pose.orientation.z;
    -            p["pose"]["orientation"]["w"] = point.pose.orientation.w;
    -            p["steering_angle"] = point.steering_angle;
    -            p["velocity"] = point.velocity;
    -            p["curvature"] = point.curvature;
    -            points.push_back(p);
    -        }
    -        j["points"] = points;
    -        
    -        return publish("auto_driving/planning_path", j.dump());
    -    } catch (const std::exception& e) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), 
    -            "发布规划路径失败: %s", e.what());
    -        return false;
    -    }
    -}
    -
    -auto_msgs::msg::GridMap MqttBridge::parseGridMap(const std::string& json_str) {
    -    auto_msgs::msg::GridMap map;
    -    
    -    try {
    -        json j = json::parse(json_str);
    -        
    -        map.header.frame_id = j["header"]["frame_id"];
    -        map.header.stamp.sec = j["header"]["stamp"]["sec"];
    -        map.header.stamp.nanosec = j["header"]["stamp"]["nanosec"];
    -        map.width = j["width"];
    -        map.height = j["height"];
    -        map.resolution = j["resolution"];
    -        map.origin.position.x = j["origin"]["position"]["x"];
    -        map.origin.position.y = j["origin"]["position"]["y"];
    -        map.origin.position.z = j["origin"]["position"]["z"];
    -        map.origin.orientation.x = j["origin"]["orientation"]["x"];
    -        map.origin.orientation.y = j["origin"]["orientation"]["y"];
    -        map.origin.orientation.z = j["origin"]["orientation"]["z"];
    -        map.origin.orientation.w = j["origin"]["orientation"]["w"];
    -        
    -        // 解析地图数据
    -        auto data = j["data"].get<std::vector<uint8_t>>();
    -        map.data.resize(data.size());
    -        for (size_t i = 0; i < data.size(); ++i) {
    -            map.data[i] = static_cast<int8_t>(data[i]);
    -        }
    -    } catch (const std::exception& e) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), 
    -            "解析网格地图失败: %s", e.what());
    -    }
    -    
    -    return map;
    -}
    -
    -geometry_msgs::msg::PoseStamped MqttBridge::parsePoseStamped(const std::string& json_str) {
    -    geometry_msgs::msg::PoseStamped pose;
    -    
    -    try {
    -        json j = json::parse(json_str);
    -        
    -        pose.header.frame_id = j["header"]["frame_id"];
    -        pose.header.stamp.sec = j["header"]["stamp"]["sec"];
    -        pose.header.stamp.nanosec = j["header"]["stamp"]["nanosec"];
    -        pose.pose.position.x = j["pose"]["position"]["x"];
    -        pose.pose.position.y = j["pose"]["position"]["y"];
    -        pose.pose.position.z = j["pose"]["position"]["z"];
    -        pose.pose.orientation.x = j["pose"]["orientation"]["x"];
    -        pose.pose.orientation.y = j["pose"]["orientation"]["y"];
    -        pose.pose.orientation.z = j["pose"]["orientation"]["z"];
    -        pose.pose.orientation.w = j["pose"]["orientation"]["w"];
    -    } catch (const std::exception& e) {
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), 
    -            "解析位姿失败: %s", e.what());
    -    }
    -    
    -    return pose;
    -}
    -
    -// 静态回调函数
    -void MqttBridge::onConnect(struct mosquitto* mosq, void* obj, int rc) {
    -    auto* bridge = static_cast<MqttBridge*>(obj);
    -    if (rc == 0) {
    -        bridge->connected_ = true;
    -        RCLCPP_INFO(rclcpp::get_logger("mqtt_bridge"), 
    -            "已连接到MQTT代理 %s:%d", bridge->host_.c_str(), bridge->port_);
    -    } else {
    -        bridge->connected_ = false;
    -        RCLCPP_ERROR(rclcpp::get_logger("mqtt_bridge"), 
    -            "连接到MQTT代理失败: %s", mosquitto_connack_string(rc));
    -    }
    -}
    -
    -void MqttBridge::onDisconnect(struct mosquitto* mosq, void* obj, int reason) {
    -    auto* bridge = static_cast<MqttBridge*>(obj);
    -    bridge->connected_ = false;
    -    RCLCPP_INFO(rclcpp::get_logger("mqtt_bridge"), 
    -        "与MQTT代理断开连接: %s", mosquitto_strerror(reason));
    -}
    -
    -void MqttBridge::onMessage(struct mosquitto* mosq, void* obj, 
    -                         const struct mosquitto_message* message) {
    -    auto* bridge = static_cast<MqttBridge*>(obj);
    -    
    -    if (bridge->message_callback_) {
    -        std::string topic = message->topic;
    -        std::string payload;
    -        
    -        if (message->payload) {
    -            payload = std::string(static_cast<const char*>(message->payload), message->payloadlen);
    -        }
    -        
    -        bridge->message_callback_(topic, payload);
    -    }
    +
    +    bridge->message_callback_(topic, payload);
    +  }
    
    Code style divergence in file 'src/mqtt_bridge_node.cpp':
    
    --- src/mqtt_bridge_node.cpp
    +++ src/mqtt_bridge_node.cpp.uncrustify
    @@ -14 +14,2 @@
    -namespace auto_simulation {
    +namespace auto_simulation
    +{
    @@ -16 +17,2 @@
    -class MqttBridgeNode : public rclcpp::Node {
    +class MqttBridgeNode : public rclcpp::Node
    +{
    @@ -18,48 +20,31 @@
    -    MqttBridgeNode() : Node("mqtt_bridge_node") {
    -        // 从参数获取MQTT设置
    -        this->declare_parameter("mqtt_host", "localhost");
    -        this->declare_parameter("mqtt_port", 1883);
    -        this->declare_parameter("mqtt_client_id", "auto_driving_bridge");
    -        
    -        std::string mqtt_host = this->get_parameter("mqtt_host").as_string();
    -        int mqtt_port = this->get_parameter("mqtt_port").as_int();
    -        std::string mqtt_client_id = this->get_parameter("mqtt_client_id").as_string();
    -        
    -        // 创建MQTT桥接
    -        try {
    -            mqtt_bridge_ = std::make_unique<MqttBridge>(
    -                mqtt_client_id, mqtt_host, mqtt_port);
    -                
    -            mqtt_bridge_->setMessageCallback(
    -                std::bind(&MqttBridgeNode::mqttMessageCallback, this, 
    -                          std::placeholders::_1, std::placeholders::_2));
    -                          
    -            if (!mqtt_bridge_->connect()) {
    -                RCLCPP_ERROR(this->get_logger(), "无法连接到MQTT代理");
    -            } else {
    -                // 订阅相关主题
    -                mqtt_bridge_->subscribe("auto_driving/command/#");
    -                RCLCPP_INFO(this->get_logger(), "已连接到MQTT代理");
    -            }
    -        } catch (const std::exception& e) {
    -            RCLCPP_ERROR(this->get_logger(), "创建MQTT桥接失败: %s", e.what());
    -        }
    -        
    -        // 创建ROS订阅者
    -        map_sub_ = this->create_subscription<auto_msgs::msg::GridMap>(
    -            "grid_map", 10, std::bind(&MqttBridgeNode::mapCallback, this, _1));
    -            
    -        path_sub_ = this->create_subscription<auto_msgs::msg::PlanningPath>(
    -            "planning_path", 10, std::bind(&MqttBridgeNode::pathCallback, this, _1));
    -            
    -        // 创建定时器
    -        mqtt_timer_ = this->create_wall_timer(
    -            10ms, std::bind(&MqttBridgeNode::processMessages, this));
    -            
    -        RCLCPP_INFO(this->get_logger(), "MQTT桥接节点已启动");
    -    }
    -    
    -    ~MqttBridgeNode() {
    -        if (mqtt_bridge_) {
    -            mqtt_bridge_->disconnect();
    -        }
    +  MqttBridgeNode()
    +  : Node("mqtt_bridge_node")
    +  {
    +    // 从参数获取MQTT设置
    +    this->declare_parameter("mqtt_host", "localhost");
    +    this->declare_parameter("mqtt_port", 1883);
    +    this->declare_parameter("mqtt_client_id", "auto_driving_bridge");
    +
    +    std::string mqtt_host = this->get_parameter("mqtt_host").as_string();
    +    int mqtt_port = this->get_parameter("mqtt_port").as_int();
    +    std::string mqtt_client_id = this->get_parameter("mqtt_client_id").as_string();
    +
    +    // 创建MQTT桥接
    +    try {
    +      mqtt_bridge_ = std::make_unique<MqttBridge>(
    +        mqtt_client_id, mqtt_host, mqtt_port);
    +
    +      mqtt_bridge_->setMessageCallback(
    +        std::bind(
    +          &MqttBridgeNode::mqttMessageCallback, this,
    +          std::placeholders::_1, std::placeholders::_2));
    +
    +      if (!mqtt_bridge_->connect()) {
    +        RCLCPP_ERROR(this->get_logger(), "无法连接到MQTT代理");
    +      } else {
    +        // 订阅相关主题
    +        mqtt_bridge_->subscribe("auto_driving/command/#");
    +        RCLCPP_INFO(this->get_logger(), "已连接到MQTT代理");
    +      }
    +    } catch (const std::exception & e) {
    +      RCLCPP_ERROR(this->get_logger(), "创建MQTT桥接失败: %s", e.what());
    @@ -67,0 +53,21 @@
    +    // 创建ROS订阅者
    +    map_sub_ = this->create_subscription<auto_msgs::msg::GridMap>(
    +      "grid_map", 10, std::bind(&MqttBridgeNode::mapCallback, this, _1));
    +
    +    path_sub_ = this->create_subscription<auto_msgs::msg::PlanningPath>(
    +      "planning_path", 10, std::bind(&MqttBridgeNode::pathCallback, this, _1));
    +
    +    // 创建定时器
    +    mqtt_timer_ = this->create_wall_timer(
    +      10ms, std::bind(&MqttBridgeNode::processMessages, this));
    +
    +    RCLCPP_INFO(this->get_logger(), "MQTT桥接节点已启动");
    +  }
    +
    +  ~MqttBridgeNode()
    +  {
    +    if (mqtt_bridge_) {
    +      mqtt_bridge_->disconnect();
    +    }
    +  }
    +
    @@ -69,4 +75,4 @@
    -    void mapCallback(const auto_msgs::msg::GridMap::SharedPtr msg) {
    -        if (mqtt_bridge_ && msg) {
    -            mqtt_bridge_->publishGridMap(*msg);
    -        }
    +  void mapCallback(const auto_msgs::msg::GridMap::SharedPtr msg)
    +  {
    +    if (mqtt_bridge_ && msg) {
    +      mqtt_bridge_->publishGridMap(*msg);
    @@ -74,5 +80,6 @@
    -    
    -    void pathCallback(const auto_msgs::msg::PlanningPath::SharedPtr msg) {
    -        if (mqtt_bridge_ && msg) {
    -            mqtt_bridge_->publishPlanningPath(*msg);
    -        }
    +  }
    +
    +  void pathCallback(const auto_msgs::msg::PlanningPath::SharedPtr msg)
    +  {
    +    if (mqtt_bridge_ && msg) {
    +      mqtt_bridge_->publishPlanningPath(*msg);
    @@ -80,13 +87,14 @@
    -    
    -    void mqttMessageCallback(const std::string& topic, const std::string& payload) {
    -        RCLCPP_INFO(this->get_logger(), "收到MQTT消息: %s", topic.c_str());
    -        
    -        try {
    -            if (topic == "auto_driving/command/request_map") {
    -                // TODO: 请求最新的地图
    -            } else if (topic == "auto_driving/command/set_goal") {
    -                // TODO: 设置新的目标点
    -            }
    -        } catch (const std::exception& e) {
    -            RCLCPP_ERROR(this->get_logger(), "处理MQTT消息失败: %s", e.what());
    -        }
    +  }
    +
    +  void mqttMessageCallback(const std::string & topic, const std::string & payload)
    +  {
    +    RCLCPP_INFO(this->get_logger(), "收到MQTT消息: %s", topic.c_str());
    +
    +    try {
    +      if (topic == "auto_driving/command/request_map") {
    +        // TODO: 请求最新的地图
    +      } else if (topic == "auto_driving/command/set_goal") {
    +        // TODO: 设置新的目标点
    +      }
    +    } catch (const std::exception & e) {
    +      RCLCPP_ERROR(this->get_logger(), "处理MQTT消息失败: %s", e.what());
    @@ -94,5 +102,6 @@
    -    
    -    void processMessages() {
    -        if (mqtt_bridge_) {
    -            mqtt_bridge_->spin(0);
    -        }
    +  }
    +
    +  void processMessages()
    +  {
    +    if (mqtt_bridge_) {
    +      mqtt_bridge_->spin(0);
    @@ -100,6 +109,7 @@
    -    
    -    std::unique_ptr<MqttBridge> mqtt_bridge_;
    -    
    -    rclcpp::Subscription<auto_msgs::msg::GridMap>::SharedPtr map_sub_;
    -    rclcpp::Subscription<auto_msgs::msg::PlanningPath>::SharedPtr path_sub_;
    -    rclcpp::TimerBase::SharedPtr mqtt_timer_;
    +  }
    +
    +  std::unique_ptr<MqttBridge> mqtt_bridge_;
    +
    +  rclcpp::Subscription<auto_msgs::msg::GridMap>::SharedPtr map_sub_;
    +  rclcpp::Subscription<auto_msgs::msg::PlanningPath>::SharedPtr path_sub_;
    +  rclcpp::TimerBase::SharedPtr mqtt_timer_;
    @@ -110,6 +120,7 @@
    -int main(int argc, char * argv[]) {
    -    rclcpp::init(argc, argv);
    -    auto node = std::make_shared<auto_simulation::MqttBridgeNode>();
    -    rclcpp::spin(node);
    -    rclcpp::shutdown();
    -    return 0;
    +int main(int argc, char * argv[])
    +{
    +  rclcpp::init(argc, argv);
    +  auto node = std::make_shared<auto_simulation::MqttBridgeNode>();
    +  rclcpp::spin(node);
    +  rclcpp::shutdown();
    +  return 0;
    
    Code style divergence in file 'src/simulation_node.cpp':
    
    --- src/simulation_node.cpp
    +++ src/simulation_node.cpp.uncrustify
    @@ -17,3 +17,5 @@
    -namespace auto_simulation {
    -
    -class SimulationNode : public rclcpp::Node {
    +namespace auto_simulation
    +{
    +
    +class SimulationNode : public rclcpp::Node
    +{
    @@ -21,19 +23,23 @@
    -    SimulationNode() : Node("simulation_node") {
    -        // 创建发布者
    -        map_pub_ = this->create_publisher<auto_msgs::msg::GridMap>("grid_map", 10);
    -        vis_pub_ = this->create_publisher<visualization_msgs::msg::MarkerArray>("visualization_marker_array", 10);
    -        planning_request_pub_ = this->create_publisher<auto_msgs::msg::PlanningRequest>("planning_request", 10);
    -        
    -        // 创建订阅者
    -        path_sub_ = this->create_subscription<auto_msgs::msg::PlanningPath>(
    -            "planning_path", 10, std::bind(&SimulationNode::pathCallback, this, std::placeholders::_1));
    -        
    -        // 创建定时器
    -        map_timer_ = this->create_wall_timer(
    -            5s, std::bind(&SimulationNode::publishMap, this));
    -        
    -        request_timer_ = this->create_wall_timer(
    -            10s, std::bind(&SimulationNode::sendPlanningRequest, this));
    -        
    -        RCLCPP_INFO(this->get_logger(), "模拟节点已启动");
    -    }
    +  SimulationNode()
    +  : Node("simulation_node")
    +  {
    +    // 创建发布者
    +    map_pub_ = this->create_publisher<auto_msgs::msg::GridMap>("grid_map", 10);
    +    vis_pub_ = this->create_publisher<visualization_msgs::msg::MarkerArray>(
    +      "visualization_marker_array", 10);
    +    planning_request_pub_ = this->create_publisher<auto_msgs::msg::PlanningRequest>(
    +      "planning_request", 10);
    +
    +    // 创建订阅者
    +    path_sub_ = this->create_subscription<auto_msgs::msg::PlanningPath>(
    +      "planning_path", 10, std::bind(&SimulationNode::pathCallback, this, std::placeholders::_1));
    +
    +    // 创建定时器
    +    map_timer_ = this->create_wall_timer(
    +      5s, std::bind(&SimulationNode::publishMap, this));
    +
    +    request_timer_ = this->create_wall_timer(
    +      10s, std::bind(&SimulationNode::sendPlanningRequest, this));
    +
    +    RCLCPP_INFO(this->get_logger(), "模拟节点已启动");
    +  }
    @@ -42,42 +48,40 @@
    -    void publishMap() {
    -        auto_msgs::msg::GridMap map;
    -        map.header.stamp = this->now();
    -        map.header.frame_id = "map";
    -        
    -        // 设置地图尺寸和分辨率
    -        map.width = 100;
    -        map.height = 100;
    -        map.resolution = 0.5;  // 每个网格0.5米
    -        
    -        // 设置地图原点
    -        map.origin.position.x = -25.0;
    -        map.origin.position.y = -25.0;
    -        map.origin.position.z = 0.0;
    -        map.origin.orientation.w = 1.0;
    -        
    -        // 初始化地图数据（所有单元格默认为0，表示可通行）
    -        map.data.resize(map.width * map.height, 0);
    -        
    -        // 添加一些随机障碍物
    -        std::random_device rd;
    -        std::mt19937 gen(rd());
    -        std::uniform_int_distribution<> dis_x(10, map.width - 10);
    -        std::uniform_int_distribution<> dis_y(10, map.height - 10);
    -        std::uniform_int_distribution<> dis_size(5, 15);
    -        
    -        // 添加几个随机形状的障碍物
    -        for (int i = 0; i < 5; ++i) {
    -            int center_x = dis_x(gen);
    -            int center_y = dis_y(gen);
    -            int size = dis_size(gen);
    -            
    -            for (int dx = -size/2; dx <= size/2; ++dx) {
    -                for (int dy = -size/2; dy <= size/2; ++dy) {
    -                    if (dx*dx + dy*dy <= size*size/4) {  // 圆形障碍物
    -                        int x = center_x + dx;
    -                        int y = center_y + dy;
    -                        if (x >= 0 && x < map.width && y >= 0 && y < map.height) {
    -                            map.data[y * map.width + x] = 100;  // 100表示障碍物
    -                        }
    -                    }
    -                }
    +  void publishMap()
    +  {
    +    auto_msgs::msg::GridMap map;
    +    map.header.stamp = this->now();
    +    map.header.frame_id = "map";
    +
    +    // 设置地图尺寸和分辨率
    +    map.width = 100;
    +    map.height = 100;
    +    map.resolution = 0.5;      // 每个网格0.5米
    +
    +    // 设置地图原点
    +    map.origin.position.x = -25.0;
    +    map.origin.position.y = -25.0;
    +    map.origin.position.z = 0.0;
    +    map.origin.orientation.w = 1.0;
    +
    +    // 初始化地图数据（所有单元格默认为0，表示可通行）
    +    map.data.resize(map.width * map.height, 0);
    +
    +    // 添加一些随机障碍物
    +    std::random_device rd;
    +    std::mt19937 gen(rd());
    +    std::uniform_int_distribution<> dis_x(10, map.width - 10);
    +    std::uniform_int_distribution<> dis_y(10, map.height - 10);
    +    std::uniform_int_distribution<> dis_size(5, 15);
    +
    +    // 添加几个随机形状的障碍物
    +    for (int i = 0; i < 5; ++i) {
    +      int center_x = dis_x(gen);
    +      int center_y = dis_y(gen);
    +      int size = dis_size(gen);
    +
    +      for (int dx = -size / 2; dx <= size / 2; ++dx) {
    +        for (int dy = -size / 2; dy <= size / 2; ++dy) {
    +          if (dx * dx + dy * dy <= size * size / 4) {    // 圆形障碍物
    +            int x = center_x + dx;
    +            int y = center_y + dy;
    +            if (x >= 0 && x < map.width && y >= 0 && y < map.height) {
    +              map.data[y * map.width + x] = 100;                // 100表示障碍物
    @@ -85,303 +89,317 @@
    -        }
    -        
    -        // 添加一些线性障碍物（墙壁）
    -        for (int i = 0; i < 3; ++i) {
    -            int start_x = dis_x(gen);
    -            int start_y = dis_y(gen);
    -            int end_x = dis_x(gen);
    -            int end_y = dis_y(gen);
    -            
    -            // 绘制线段
    -            int dx = std::abs(end_x - start_x);
    -            int dy = std::abs(end_y - start_y);
    -            int sx = (start_x < end_x) ? 1 : -1;
    -            int sy = (start_y < end_y) ? 1 : -1;
    -            int err = dx - dy;
    -            
    -            int x = start_x;
    -            int y = start_y;
    -            while (true) {
    -                if (x >= 0 && x < map.width && y >= 0 && y < map.height) {
    -                    map.data[y * map.width + x] = 100;
    -                }
    -                
    -                if (x == end_x && y == end_y) break;
    -                
    -                int e2 = 2 * err;
    -                if (e2 > -dy) {
    -                    err -= dy;
    -                    x += sx;
    -                }
    -                if (e2 < dx) {
    -                    err += dx;
    -                    y += sy;
    -                }
    -            }
    -        }
    -        
    -        // 发布地图
    -        map_pub_->publish(map);
    -        RCLCPP_INFO(this->get_logger(), "已发布地图");
    -        
    -        // 保存当前地图用于路径规划
    -        current_map_ = map;
    -        
    -        // 可视化地图
    -        publishMapVisualization(map);
    -    }
    -    
    -    void publishMapVisualization(const auto_msgs::msg::GridMap& map) {
    -        visualization_msgs::msg::MarkerArray marker_array;
    -        
    -        // 创建障碍物可视化标记
    -        visualization_msgs::msg::Marker obstacle_marker;
    -        obstacle_marker.header = map.header;
    -        obstacle_marker.ns = "obstacles";
    -        obstacle_marker.id = 0;
    -        obstacle_marker.type = visualization_msgs::msg::Marker::CUBE_LIST;
    -        obstacle_marker.action = visualization_msgs::msg::Marker::ADD;
    -        obstacle_marker.scale.x = map.resolution;
    -        obstacle_marker.scale.y = map.resolution;
    -        obstacle_marker.scale.z = 0.1;
    -        obstacle_marker.color.r = 1.0;
    -        obstacle_marker.color.g = 0.0;
    -        obstacle_marker.color.b = 0.0;
    -        obstacle_marker.color.a = 1.0;
    -        obstacle_marker.pose.orientation.w = 1.0;
    -        
    -        // 遍历地图添加障碍物
    -        for (size_t y = 0; y < map.height; ++y) {
    -            for (size_t x = 0; x < map.width; ++x) {
    -                if (map.data[y * map.width + x] == 100) {  // 障碍物
    -                    geometry_msgs::msg::Point p;
    -                    p.x = map.origin.position.x + (x + 0.5) * map.resolution;
    -                    p.y = map.origin.position.y + (y + 0.5) * map.resolution;
    -                    p.z = 0.05;
    -                    obstacle_marker.points.push_back(p);
    -                }
    -            }
    -        }
    -        
    -        marker_array.markers.push_back(obstacle_marker);
    -        vis_pub_->publish(marker_array);
    -    }
    -    
    -    void sendPlanningRequest() {
    -        if (current_map_.width == 0 || current_map_.height == 0) {
    -            RCLCPP_WARN(this->get_logger(), "尚未生成地图，无法发送规划请求");
    -            return;
    -        }
    -        
    -        auto_msgs::msg::PlanningRequest request;
    -        request.header.stamp = this->now();
    -        request.header.frame_id = "map";
    -        
    -        // 设置起点和终点
    -        std::random_device rd;
    -        std::mt19937 gen(rd());
    -        
    -        // 在地图有效区域内随机选择起点和终点
    -        bool valid_request = false;
    -        int max_attempts = 100;
    -        
    -        while (!valid_request && max_attempts > 0) {
    -            // 随机选择起点和终点在地图内的位置
    -            std::uniform_int_distribution<> dis_x(5, current_map_.width - 5);
    -            std::uniform_int_distribution<> dis_y(5, current_map_.height - 5);
    -            
    -            int start_x = dis_x(gen);
    -            int start_y = dis_y(gen);
    -            int goal_x = dis_x(gen);
    -            int goal_y = dis_y(gen);
    -            
    -            // 确保起点和终点是空闲的
    -            if (current_map_.data[start_y * current_map_.width + start_x] == 0 && 
    -                current_map_.data[goal_y * current_map_.width + goal_x] == 0) {
    -                
    -                // 确保起点和终点有一定距离
    -                double dx = start_x - goal_x;
    -                double dy = start_y - goal_y;
    -                double distance = std::sqrt(dx*dx + dy*dy);
    -                
    -                if (distance > 40.0) {  // 至少40个网格单元
    -                    // 设置起点
    -                    request.start.header = request.header;
    -                    request.start.pose.position.x = current_map_.origin.position.x + (start_x + 0.5) * current_map_.resolution;
    -                    request.start.pose.position.y = current_map_.origin.position.y + (start_y + 0.5) * current_map_.resolution;
    -                    request.start.pose.position.z = 0.0;
    -                    
    -                    // 随机朝向
    -                    std::uniform_real_distribution<> dis_angle(0, 2 * M_PI);
    -                    double start_angle = dis_angle(gen);
    -                    request.start.pose.orientation.w = std::cos(start_angle / 2.0);
    -                    request.start.pose.orientation.z = std::sin(start_angle / 2.0);
    -                    
    -                    // 设置终点
    -                    request.goal.header = request.header;
    -                    request.goal.pose.position.x = current_map_.origin.position.x + (goal_x + 0.5) * current_map_.resolution;
    -                    request.goal.pose.position.y = current_map_.origin.position.y + (goal_y + 0.5) * current_map_.resolution;
    -                    request.goal.pose.position.z = 0.0;
    -                    
    -                    double goal_angle = dis_angle(gen);
    -                    request.goal.pose.orientation.w = std::cos(goal_angle / 2.0);
    -                    request.goal.pose.orientation.z = std::sin(goal_angle / 2.0);
    -                    
    -                    valid_request = true;
    -                }
    -            }
    -            
    -            max_attempts--;
    -        }
    -        
    -        if (!valid_request) {
    -            RCLCPP_ERROR(this->get_logger(), "无法生成有效的规划请求，请重试");
    -            return;
    -        }
    -        
    -        // 随机选择规划器类型
    -        std::uniform_int_distribution<> dis_planner(0, 1);
    -        request.planner_type = (dis_planner(gen) == 0) ? "astar" : "hybrid_astar";
    -        
    -        // 是否考虑运动学约束（对Hybrid A*有效）
    -        request.consider_kinematic = (request.planner_type == "hybrid_astar");
    -        
    -        // 发布规划请求
    -        planning_request_pub_->publish(request);
    -        RCLCPP_INFO(this->get_logger(), "已发送规划请求，规划器类型: %s", request.planner_type.c_str());
    -        
    -        // 可视化起点和终点
    -        publishStartGoalVisualization(request.start, request.goal);
    -    }
    -    
    -    void publishStartGoalVisualization(
    -        const geometry_msgs::msg::PoseStamped& start,
    -        const geometry_msgs::msg::PoseStamped& goal) {
    -        
    -        visualization_msgs::msg::MarkerArray marker_array;
    -        
    -        // 创建起点标记
    -        visualization_msgs::msg::Marker start_marker;
    -        start_marker.header = start.header;
    -        start_marker.ns = "planning_points";
    -        start_marker.id = 1;
    -        start_marker.type = visualization_msgs::msg::Marker::ARROW;
    -        start_marker.action = visualization_msgs::msg::Marker::ADD;
    -        start_marker.pose = start.pose;
    -        start_marker.scale.x = 2.0;  // 箭头长度
    -        start_marker.scale.y = 0.5;  // 箭头宽度
    -        start_marker.scale.z = 0.5;  // 箭头高度
    -        start_marker.color.r = 0.0;
    -        start_marker.color.g = 1.0;
    -        start_marker.color.b = 0.0;
    -        start_marker.color.a = 1.0;
    -        
    -        // 创建终点标记
    -        visualization_msgs::msg::Marker goal_marker;
    -        goal_marker.header = goal.header;
    -        goal_marker.ns = "planning_points";
    -        goal_marker.id = 2;
    -        goal_marker.type = visualization_msgs::msg::Marker::ARROW;
    -        goal_marker.action = visualization_msgs::msg::Marker::ADD;
    -        goal_marker.pose = goal.pose;
    -        goal_marker.scale.x = 2.0;
    -        goal_marker.scale.y = 0.5;
    -        goal_marker.scale.z = 0.5;
    -        goal_marker.color.r = 1.0;
    -        goal_marker.color.g = 0.0;
    -        goal_marker.color.b = 1.0;
    -        goal_marker.color.a = 1.0;
    -        
    -        marker_array.markers.push_back(start_marker);
    -        marker_array.markers.push_back(goal_marker);
    -        vis_pub_->publish(marker_array);
    -    }
    -    
    -    void pathCallback(const auto_msgs::msg::PlanningPath::SharedPtr msg) {
    -        RCLCPP_INFO(this->get_logger(), "收到规划路径，长度: %.2f米，规划时间: %.2f秒",
    -                  msg->total_distance, msg->planning_time);
    -        
    -        // 可视化路径
    -        publishPathVisualization(*msg);
    -    }
    -    
    -    void publishPathVisualization(const auto_msgs::msg::PlanningPath& path) {
    -        visualization_msgs::msg::MarkerArray marker_array;
    -        
    -        // 创建路径标记
    -        visualization_msgs::msg::Marker path_marker;
    -        path_marker.header = path.header;
    -        path_marker.ns = "planning_path";
    -        path_marker.id = 0;
    -        path_marker.type = visualization_msgs::msg::Marker::LINE_STRIP;
    -        path_marker.action = visualization_msgs::msg::Marker::ADD;
    -        path_marker.scale.x = 0.2;  // 线宽
    -        
    -        // 根据规划器类型设置不同颜色
    -        if (path.planner_type == "astar") {
    -            path_marker.color.r = 0.0;
    -            path_marker.color.g = 0.0;
    -            path_marker.color.b = 1.0;
    -        } else {  // hybrid_astar
    -            path_marker.color.r = 0.0;
    -            path_marker.color.g = 1.0;
    -            path_marker.color.b = 1.0;
    -        }
    -        path_marker.color.a = 1.0;
    -        
    -        // 添加路径点
    -        for (const auto& point : path.points) {
    -            geometry_msgs::msg::Point p;
    -            p.x = point.pose.position.x;
    -            p.y = point.pose.position.y;
    -            p.z = 0.1;  // 略高于地图平面
    -            path_marker.points.push_back(p);
    -        }
    -        
    -        // 创建路径点标记（特别是对Hybrid A*展示方向）
    -        if (path.planner_type == "hybrid_astar") {
    -            visualization_msgs::msg::Marker arrows_marker;
    -            arrows_marker.header = path.header;
    -            arrows_marker.ns = "planning_path";
    -            arrows_marker.id = 1;
    -            arrows_marker.type = visualization_msgs::msg::Marker::ARROW;
    -            arrows_marker.action = visualization_msgs::msg::Marker::ADD;
    -            
    -            // 每隔几个点放一个箭头表示方向
    -            for (size_t i = 0; i < path.points.size(); i += 5) {
    -                visualization_msgs::msg::Marker arrow;
    -                arrow.header = path.header;
    -                arrow.ns = "path_direction";
    -                arrow.id = i;
    -                arrow.type = visualization_msgs::msg::Marker::ARROW;
    -                arrow.action = visualization_msgs::msg::Marker::ADD;
    -                arrow.pose = path.points[i].pose;
    -                arrow.scale.x = 1.0;  // 箭头长度
    -                arrow.scale.y = 0.2;  // 箭头宽度
    -                arrow.scale.z = 0.2;  // 箭头高度
    -                arrow.color.r = 1.0;
    -                arrow.color.g = 1.0;
    -                arrow.color.b = 0.0;
    -                arrow.color.a = 1.0;
    -                
    -                marker_array.markers.push_back(arrow);
    -            }
    -        }
    -        
    -        marker_array.markers.push_back(path_marker);
    -        vis_pub_->publish(marker_array);
    -    }
    -    
    -    // 发布者
    -    rclcpp::Publisher<auto_msgs::msg::GridMap>::SharedPtr map_pub_;
    -    rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr vis_pub_;
    -    rclcpp::Publisher<auto_msgs::msg::PlanningRequest>::SharedPtr planning_request_pub_;
    -    
    -    // 订阅者
    -    rclcpp::Subscription<auto_msgs::msg::PlanningPath>::SharedPtr path_sub_;
    -    
    -    // 定时器
    -    rclcpp::TimerBase::SharedPtr map_timer_;
    -    rclcpp::TimerBase::SharedPtr request_timer_;
    -    
    -    // 当前地图
    -    auto_msgs::msg::GridMap current_map_;
    +          }
    +        }
    +      }
    +    }
    +
    +    // 添加一些线性障碍物（墙壁）
    +    for (int i = 0; i < 3; ++i) {
    +      int start_x = dis_x(gen);
    +      int start_y = dis_y(gen);
    +      int end_x = dis_x(gen);
    +      int end_y = dis_y(gen);
    +
    +      // 绘制线段
    +      int dx = std::abs(end_x - start_x);
    +      int dy = std::abs(end_y - start_y);
    +      int sx = (start_x < end_x) ? 1 : -1;
    +      int sy = (start_y < end_y) ? 1 : -1;
    +      int err = dx - dy;
    +
    +      int x = start_x;
    +      int y = start_y;
    +      while (true) {
    +        if (x >= 0 && x < map.width && y >= 0 && y < map.height) {
    +          map.data[y * map.width + x] = 100;
    +        }
    +
    +        if (x == end_x && y == end_y) {break;}
    +
    +        int e2 = 2 * err;
    +        if (e2 > -dy) {
    +          err -= dy;
    +          x += sx;
    +        }
    +        if (e2 < dx) {
    +          err += dx;
    +          y += sy;
    +        }
    +      }
    +    }
    +
    +    // 发布地图
    +    map_pub_->publish(map);
    +    RCLCPP_INFO(this->get_logger(), "已发布地图");
    +
    +    // 保存当前地图用于路径规划
    +    current_map_ = map;
    +
    +    // 可视化地图
    +    publishMapVisualization(map);
    +  }
    +
    +  void publishMapVisualization(const auto_msgs::msg::GridMap & map)
    +  {
    +    visualization_msgs::msg::MarkerArray marker_array;
    +
    +    // 创建障碍物可视化标记
    +    visualization_msgs::msg::Marker obstacle_marker;
    +    obstacle_marker.header = map.header;
    +    obstacle_marker.ns = "obstacles";
    +    obstacle_marker.id = 0;
    +    obstacle_marker.type = visualization_msgs::msg::Marker::CUBE_LIST;
    +    obstacle_marker.action = visualization_msgs::msg::Marker::ADD;
    +    obstacle_marker.scale.x = map.resolution;
    +    obstacle_marker.scale.y = map.resolution;
    +    obstacle_marker.scale.z = 0.1;
    +    obstacle_marker.color.r = 1.0;
    +    obstacle_marker.color.g = 0.0;
    +    obstacle_marker.color.b = 0.0;
    +    obstacle_marker.color.a = 1.0;
    +    obstacle_marker.pose.orientation.w = 1.0;
    +
    +    // 遍历地图添加障碍物
    +    for (size_t y = 0; y < map.height; ++y) {
    +      for (size_t x = 0; x < map.width; ++x) {
    +        if (map.data[y * map.width + x] == 100) {          // 障碍物
    +          geometry_msgs::msg::Point p;
    +          p.x = map.origin.position.x + (x + 0.5) * map.resolution;
    +          p.y = map.origin.position.y + (y + 0.5) * map.resolution;
    +          p.z = 0.05;
    +          obstacle_marker.points.push_back(p);
    +        }
    +      }
    +    }
    +
    +    marker_array.markers.push_back(obstacle_marker);
    +    vis_pub_->publish(marker_array);
    +  }
    +
    +  void sendPlanningRequest()
    +  {
    +    if (current_map_.width == 0 || current_map_.height == 0) {
    +      RCLCPP_WARN(this->get_logger(), "尚未生成地图，无法发送规划请求");
    +      return;
    +    }
    +
    +    auto_msgs::msg::PlanningRequest request;
    +    request.header.stamp = this->now();
    +    request.header.frame_id = "map";
    +
    +    // 设置起点和终点
    +    std::random_device rd;
    +    std::mt19937 gen(rd());
    +
    +    // 在地图有效区域内随机选择起点和终点
    +    bool valid_request = false;
    +    int max_attempts = 100;
    +
    +    while (!valid_request && max_attempts > 0) {
    +      // 随机选择起点和终点在地图内的位置
    +      std::uniform_int_distribution<> dis_x(5, current_map_.width - 5);
    +      std::uniform_int_distribution<> dis_y(5, current_map_.height - 5);
    +
    +      int start_x = dis_x(gen);
    +      int start_y = dis_y(gen);
    +      int goal_x = dis_x(gen);
    +      int goal_y = dis_y(gen);
    +
    +      // 确保起点和终点是空闲的
    +      if (current_map_.data[start_y * current_map_.width + start_x] == 0 &&
    +        current_map_.data[goal_y * current_map_.width + goal_x] == 0)
    +      {
    +
    +        // 确保起点和终点有一定距离
    +        double dx = start_x - goal_x;
    +        double dy = start_y - goal_y;
    +        double distance = std::sqrt(dx * dx + dy * dy);
    +
    +        if (distance > 40.0) {          // 至少40个网格单元
    +          // 设置起点
    +          request.start.header = request.header;
    +          request.start.pose.position.x = current_map_.origin.position.x + (start_x + 0.5) *
    +            current_map_.resolution;
    +          request.start.pose.position.y = current_map_.origin.position.y + (start_y + 0.5) *
    +            current_map_.resolution;
    +          request.start.pose.position.z = 0.0;
    +
    +          // 随机朝向
    +          std::uniform_real_distribution<> dis_angle(0, 2 * M_PI);
    +          double start_angle = dis_angle(gen);
    +          request.start.pose.orientation.w = std::cos(start_angle / 2.0);
    +          request.start.pose.orientation.z = std::sin(start_angle / 2.0);
    +
    +          // 设置终点
    +          request.goal.header = request.header;
    +          request.goal.pose.position.x = current_map_.origin.position.x + (goal_x + 0.5) *
    +            current_map_.resolution;
    +          request.goal.pose.position.y = current_map_.origin.position.y + (goal_y + 0.5) *
    +            current_map_.resolution;
    +          request.goal.pose.position.z = 0.0;
    +
    +          double goal_angle = dis_angle(gen);
    +          request.goal.pose.orientation.w = std::cos(goal_angle / 2.0);
    +          request.goal.pose.orientation.z = std::sin(goal_angle / 2.0);
    +
    +          valid_request = true;
    +        }
    +      }
    +
    +      max_attempts--;
    +    }
    +
    +    if (!valid_request) {
    +      RCLCPP_ERROR(this->get_logger(), "无法生成有效的规划请求，请重试");
    +      return;
    +    }
    +
    +    // 随机选择规划器类型
    +    std::uniform_int_distribution<> dis_planner(0, 1);
    +    request.planner_type = (dis_planner(gen) == 0) ? "astar" : "hybrid_astar";
    +
    +    // 是否考虑运动学约束（对Hybrid A*有效）
    +    request.consider_kinematic = (request.planner_type == "hybrid_astar");
    +
    +    // 发布规划请求
    +    planning_request_pub_->publish(request);
    +    RCLCPP_INFO(this->get_logger(), "已发送规划请求，规划器类型: %s", request.planner_type.c_str());
    +
    +    // 可视化起点和终点
    +    publishStartGoalVisualization(request.start, request.goal);
    +  }
    +
    +  void publishStartGoalVisualization(
    +    const geometry_msgs::msg::PoseStamped & start,
    +    const geometry_msgs::msg::PoseStamped & goal)
    +  {
    +
    +    visualization_msgs::msg::MarkerArray marker_array;
    +
    +    // 创建起点标记
    +    visualization_msgs::msg::Marker start_marker;
    +    start_marker.header = start.header;
    +    start_marker.ns = "planning_points";
    +    start_marker.id = 1;
    +    start_marker.type = visualization_msgs::msg::Marker::ARROW;
    +    start_marker.action = visualization_msgs::msg::Marker::ADD;
    +    start_marker.pose = start.pose;
    +    start_marker.scale.x = 2.0;      // 箭头长度
    +    start_marker.scale.y = 0.5;      // 箭头宽度
    +    start_marker.scale.z = 0.5;      // 箭头高度
    +    start_marker.color.r = 0.0;
    +    start_marker.color.g = 1.0;
    +    start_marker.color.b = 0.0;
    +    start_marker.color.a = 1.0;
    +
    +    // 创建终点标记
    +    visualization_msgs::msg::Marker goal_marker;
    +    goal_marker.header = goal.header;
    +    goal_marker.ns = "planning_points";
    +    goal_marker.id = 2;
    +    goal_marker.type = visualization_msgs::msg::Marker::ARROW;
    +    goal_marker.action = visualization_msgs::msg::Marker::ADD;
    +    goal_marker.pose = goal.pose;
    +    goal_marker.scale.x = 2.0;
    +    goal_marker.scale.y = 0.5;
    +    goal_marker.scale.z = 0.5;
    +    goal_marker.color.r = 1.0;
    +    goal_marker.color.g = 0.0;
    +    goal_marker.color.b = 1.0;
    +    goal_marker.color.a = 1.0;
    +
    +    marker_array.markers.push_back(start_marker);
    +    marker_array.markers.push_back(goal_marker);
    +    vis_pub_->publish(marker_array);
    +  }
    +
    +  void pathCallback(const auto_msgs::msg::PlanningPath::SharedPtr msg)
    +  {
    +    RCLCPP_INFO(
    +      this->get_logger(), "收到规划路径，长度: %.2f米，规划时间: %.2f秒",
    +      msg->total_distance, msg->planning_time);
    +
    +    // 可视化路径
    +    publishPathVisualization(*msg);
    +  }
    +
    +  void publishPathVisualization(const auto_msgs::msg::PlanningPath & path)
    +  {
    +    visualization_msgs::msg::MarkerArray marker_array;
    +
    +    // 创建路径标记
    +    visualization_msgs::msg::Marker path_marker;
    +    path_marker.header = path.header;
    +    path_marker.ns = "planning_path";
    +    path_marker.id = 0;
    +    path_marker.type = visualization_msgs::msg::Marker::LINE_STRIP;
    +    path_marker.action = visualization_msgs::msg::Marker::ADD;
    +    path_marker.scale.x = 0.2;      // 线宽
    +
    +    // 根据规划器类型设置不同颜色
    +    if (path.planner_type == "astar") {
    +      path_marker.color.r = 0.0;
    +      path_marker.color.g = 0.0;
    +      path_marker.color.b = 1.0;
    +    } else {      // hybrid_astar
    +      path_marker.color.r = 0.0;
    +      path_marker.color.g = 1.0;
    +      path_marker.color.b = 1.0;
    +    }
    +    path_marker.color.a = 1.0;
    +
    +    // 添加路径点
    +    for (const auto & point : path.points) {
    +      geometry_msgs::msg::Point p;
    +      p.x = point.pose.position.x;
    +      p.y = point.pose.position.y;
    +      p.z = 0.1;        // 略高于地图平面
    +      path_marker.points.push_back(p);
    +    }
    +
    +    // 创建路径点标记（特别是对Hybrid A*展示方向）
    +    if (path.planner_type == "hybrid_astar") {
    +      visualization_msgs::msg::Marker arrows_marker;
    +      arrows_marker.header = path.header;
    +      arrows_marker.ns = "planning_path";
    +      arrows_marker.id = 1;
    +      arrows_marker.type = visualization_msgs::msg::Marker::ARROW;
    +      arrows_marker.action = visualization_msgs::msg::Marker::ADD;
    +
    +      // 每隔几个点放一个箭头表示方向
    +      for (size_t i = 0; i < path.points.size(); i += 5) {
    +        visualization_msgs::msg::Marker arrow;
    +        arrow.header = path.header;
    +        arrow.ns = "path_direction";
    +        arrow.id = i;
    +        arrow.type = visualization_msgs::msg::Marker::ARROW;
    +        arrow.action = visualization_msgs::msg::Marker::ADD;
    +        arrow.pose = path.points[i].pose;
    +        arrow.scale.x = 1.0;          // 箭头长度
    +        arrow.scale.y = 0.2;          // 箭头宽度
    +        arrow.scale.z = 0.2;          // 箭头高度
    +        arrow.color.r = 1.0;
    +        arrow.color.g = 1.0;
    +        arrow.color.b = 0.0;
    +        arrow.color.a = 1.0;
    +
    +        marker_array.markers.push_back(arrow);
    +      }
    +    }
    +
    +    marker_array.markers.push_back(path_marker);
    +    vis_pub_->publish(marker_array);
    +  }
    +
    +  // 发布者
    +  rclcpp::Publisher<auto_msgs::msg::GridMap>::SharedPtr map_pub_;
    +  rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr vis_pub_;
    +  rclcpp::Publisher<auto_msgs::msg::PlanningRequest>::SharedPtr planning_request_pub_;
    +
    +  // 订阅者
    +  rclcpp::Subscription<auto_msgs::msg::PlanningPath>::SharedPtr path_sub_;
    +
    +  // 定时器
    +  rclcpp::TimerBase::SharedPtr map_timer_;
    +  rclcpp::TimerBase::SharedPtr request_timer_;
    +
    +  // 当前地图
    +  auto_msgs::msg::GridMap current_map_;
    @@ -394,5 +412,5 @@
    -    rclcpp::init(argc, argv);
    -    auto node = std::make_shared<auto_simulation::SimulationNode>();
    -    rclcpp::spin(node);
    -    rclcpp::shutdown();
    -    return 0;
    +  rclcpp::init(argc, argv);
    +  auto node = std::make_shared<auto_simulation::SimulationNode>();
    +  rclcpp::spin(node);
    +  rclcpp::shutdown();
    +  return 0;
    
    4 files with code style divergence
    -- run_test.py: return code 1
    -- run_test.py: verify result file '/home/onion/samples/autonomous_driving_ws/build/auto_simulation/test_results/auto_simulation/uncrustify.xunit.xml'
  >>>
build/auto_simulation/test_results/auto_simulation/lint_cmake.xunit.xml: 1 test, 0 errors, 1 failure, 0 skipped
- auto_simulation.lint_cmake whitespace/eol (CMakeLists.txt:34)
  <<< failure message
    Line ends in whitespace
  >>>
build/auto_simulation/test_results/auto_simulation/uncrustify.xunit.xml: 4 tests, 0 errors, 4 failures, 0 skipped
- auto_simulation.uncrustify include/auto_simulation/mqtt_bridge.hpp
  <<< failure message
    Diff with 119 lines
  >>>
- auto_simulation.uncrustify src/mqtt_bridge.cpp
  <<< failure message
    Diff with 638 lines
  >>>
- auto_simulation.uncrustify src/mqtt_bridge_node.cpp
  <<< failure message
    Diff with 201 lines
  >>>
- auto_simulation.uncrustify src/simulation_node.cpp
  <<< failure message
    Diff with 769 lines
  >>>

Summary: 45 tests, 0 errors, 20 failures, 11 skipped
